package iceCube.uhe.analysis;

import numRecipes.*;
import iceCube.uhe.analysis.*;
import java.io.*;
import java.util.*;

/**

   Calculate the p-value on given neutrino model parameters based on the binned Poisson likelihood
   for estimating the confidence interval. 

   The PoissonBinnedLikelihoodCalculator :
   <pre>
   PoissonBinnedLikelihoodCalculator  calBG     (for the atmospheric background)
   PoissonBinnedLikelihoodCalculator  calSignal   (for the neutrino model such as GZK with the parameters to be tested)
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal (for the nuisance signal - like E^-2 against the GZK test) 
   </pre>
   are generated by the correponding binned data from the files and then executes the methods
   provied by ModelTestByPoissonBinnedLikelihoodFactory.

   The signal hypothesis with all the other values of parameters are stored
   in the list container calSignalSetsList.

   The example for using this class - The constraints on the source evolution parameters (m,Zmax).


The likeliihood ratio
   <pre> 
   alternative (calBG + model stored in calSignalSetsList (+ nuisance ) with parameters to maximize Likelihood)/
   null hypothesis(calBG + calSignal with a given neutrino parameter (+ nuisance to maximize likelihood))
   </pre>
is used for the test-statstic

*/


public class ModelParaPvalueCalculatorByPoissonBinnedLH {


    /**  the poisson bin data container for BG */
    public PoissonBinnedLikelihoodCalculator calBG = null;

    /**   the container for Signal with the set of parameter values to be tested*/
    public PoissonBinnedLikelihoodCalculator calSignal;

    /**  container for Nuisance Signal for the profole likelihood */
    public PoissonBinnedLikelihoodCalculator calNuisanceSignal;

    /**  container of the signal with the model parameters that maximized likelihood */
    protected PoissonBinnedLikelihoodCalculator calSignalToMaxLH = null;

    /** The test factory */
    protected ModelTestByPoissonBinnedLikelihoodFactory testFactory = null;

    /** default number of runs in the replica experiment 
	to calculate the pdf of the likelihood ratio */
    //public static final int runTimesDefault =500000; 
    public static final int runTimesDefault =10000; 

    protected boolean includeNuisance = false;
    private boolean buildLLH = false;
    private boolean llhRatioListCreated = false;
    private boolean useQuickScan = false;
 

    /** List to store the PoissonBinnedLikelihoodCalculator calSignal with various model parameters */
    protected List calSignalSetsList = null;

    /** List to store the llh ratio list */
    private List llhRatioList = null;


    /**
       constructor:
       <pre>
   PoissonBinnedLikelihoodCalculator  calBG            :for the atmospheric background
   PoissonBinnedLikelihoodCalculator  calSignal        :for the neutrino model with the parmeters to be tested
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal:for the nuisance signal - like E^-2 against the GZK test
   List  calSignalSetsList   :  A container to store PoissonBinnedLikelihoodCalculator objects
                               of the signal hypothesis but with all the parameter values allowd in their range.
                               It will build the alternative hypothesis.
       </pre>
     */
    public ModelParaPvalueCalculatorByPoissonBinnedLH(PoissonBinnedLikelihoodCalculator calBG,
					    PoissonBinnedLikelihoodCalculator calSignal,
					    PoissonBinnedLikelihoodCalculator calNuisanceSignal,
					    List calSignalSetsList){
	this.calBG = calBG; 
	this.calSignal = calSignal; 
	this.calNuisanceSignal = calNuisanceSignal;
 
	testFactory = 
	    new  ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal,calNuisanceSignal);

	this.calSignalSetsList =  calSignalSetsList;

	includeNuisance = true;
   }


    /**
       constructor for no nuislance case:
       <pre>
   PoissonBinnedLikelihoodCalculator  calBG            :for the atmospheric background
   PoissonBinnedLikelihoodCalculator  calSignal        :for the neutrino model with the parmeters to be tested
   List  calSignalSetsList   :  A container to store PoissonBinnedLikelihoodCalculator objects
                               of the signal hypothesis but with all the parameter values allowd in their range.
                               It will build the alternative hypothesis.
       </pre>
     */
    public ModelParaPvalueCalculatorByPoissonBinnedLH(PoissonBinnedLikelihoodCalculator calBG,
					    PoissonBinnedLikelihoodCalculator calSignal,
					    List calSignalSetsList){
	this.calBG = calBG; 
	this.calSignal = calSignal; 
 
	testFactory = 
	    new  ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal);

	this.calSignalSetsList =  calSignalSetsList;

	includeNuisance = false;
   }


    /**
       constructor:
       <pre>
   PoissonBinnedLikelihoodCalculator  calBG            :for the atmospheric background
   PoissonBinnedLikelihoodCalculator  calSignal        :for the neutrino model with the parmeters to be tested
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal:for the nuisance signal - like E^-2 against the GZK test
   Map  calSignalMap   :  A container to store PoissonBinnedLikelihoodCalculator objects
                          of the signal hypothesis but with all the parameter values allowd in their range.
                          It will build the alternative hypothesis. The PoissonBinnedLikelihoodCalculator objects
			  should be stored as the key (not value) member of the map.
       </pre>
     */
    public ModelParaPvalueCalculatorByPoissonBinnedLH(PoissonBinnedLikelihoodCalculator calBG,
					    PoissonBinnedLikelihoodCalculator calSignal,
					    PoissonBinnedLikelihoodCalculator calNuisanceSignal,
					    Map calSignalMap){
	this.calBG = calBG; 
	this.calSignal = calSignal; 
	this.calNuisanceSignal = calNuisanceSignal;
 
	testFactory = 
	    new  ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal,calNuisanceSignal);

	buildCalSignalSetsListFromMap(calSignalMap);

	includeNuisance = true;
   }


    /**
       constructor for no nuislance case:
       <pre>
   PoissonBinnedLikelihoodCalculator  calBG            :for the atmospheric background
   PoissonBinnedLikelihoodCalculator  calSignal        :for the neutrino model with the parmeters to be tested
   Map  calSignalMap   :  A container to store PoissonBinnedLikelihoodCalculator objects
                          of the signal hypothesis but with all the parameter values allowd in their range.
                          It will build the alternative hypothesis. The PoissonBinnedLikelihoodCalculator objects
			  should be stored as the key (not value) member of the map.
       </pre>
     */
    public ModelParaPvalueCalculatorByPoissonBinnedLH(PoissonBinnedLikelihoodCalculator calBG,
					    PoissonBinnedLikelihoodCalculator calSignal,
					    Map calSignalMap){
	this.calBG = calBG; 
	this.calSignal = calSignal; 
 
	testFactory = 
	    new  ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal);

	buildCalSignalSetsListFromMap(calSignalMap);

	includeNuisance = false;
   }

    /** Use the quick search for the parameters to maximize LLH in the method getLLHRatio() or getPvalue().
	Scan only the models with the parameters yielding the total expected rate closer 
	to the total observed number of events.
     */
    public void useTheQuickSearchToMaximizeLLH(){
	useQuickScan = true;
    }

    /** Use the full search for the parameters to maximize LLH in the method getLLHRatio() or getPvalue().
	Scan all the models stored in calSignalSetsList. This is the default procedure. 
     */
    public void useTheFullSearchToMaximizeLLH(){
	useQuickScan = false;
    }



   /**
      Scan all the PoissonBinnedLikelihoodCalculators stored in List calSignalSetsList
      to calculate the LLH. Then indentify the one that gives a maximal likelihood.
      If you register the nuisance model in calling the constructor, the profile likelihood
      is calculated. The likelihood ratio
      <pre> 
      alternative (calBG + model stored in calSignalSetsList (+ nuisance ) with parameters to maximize Likelihood)/
      null hypothesis(calBG + calSignal with a given neutrino parameter (+ nuisance to maximize likelihood))
      </pre>
      is returned.
   */
    public double getLLHRatio(boolean runReplicaExperiment){
	double llhNull = testFactory.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	long numberOfObservedEvents = testFactory.calNull.getSumOfObservedValues();
	if(runReplicaExperiment){
	    testFactory.calNull.useTheResultsByTheReplicaExperiment();
	    numberOfObservedEvents = testFactory.calNull.getSumOfObservedValues();
	    testFactory.calNull.useTheResultsByTheRealExperiment();
	}

	double llhSignalFloated =  Double.POSITIVE_INFINITY;
	calSignalToMaxLH = null;
	ListIterator calSignalListIterator = calSignalSetsList.listIterator();
	while(calSignalListIterator.hasNext()){
	    PoissonBinnedLikelihoodCalculator calSignalTrial = 
		(PoissonBinnedLikelihoodCalculator )(calSignalListIterator.next());
	    calSignalTrial.useTheResultsByTheRealExperiment();

	    if(useQuickScan && runReplicaExperiment){
		double numberOfSigEvents = calSignalTrial.getSumOfExpectedValues();
		double numberOfBGEvents = calBG.getSumOfExpectedValues();
		FeldmanCousins.setConfidenceLevel(0.68);
		double upperLimit = FeldmanCousins.getUpperLimit(numberOfBGEvents,numberOfObservedEvents);
		double lowerLimit = FeldmanCousins.getLowerLimit(numberOfBGEvents,numberOfObservedEvents);
		//System.err.format("observed(%d) bg(%f) sig expected(%f) lowerlimit(%f) upperlimit(%f)\n",
		//		  numberOfObservedEvents, numberOfBGEvents, numberOfSigEvents, lowerLimit, upperLimit); 
		if((numberOfSigEvents>upperLimit)||( numberOfSigEvents<lowerLimit)){
                    //    System.err.println("skipped!");
		    continue;
		}
	    }

	    PoissonBinnedLikelihoodCalculator calAlterToMaxLH = new PoissonBinnedLikelihoodCalculator();
	    calAlterToMaxLH.useTheResultsByTheRealExperiment();
	    calAlterToMaxLH.copyPoissonBinnedData(testFactory.calNull); 
	    calAlterToMaxLH.copyExpectedNumbers(calBG);
	    calAlterToMaxLH.addExpectedNumbers(1.0,calSignalTrial);

	    if(runReplicaExperiment){
		calAlterToMaxLH.useTheResultsByTheReplicaExperiment();
		calAlterToMaxLH.copyPoissonBinnedData(testFactory.calNull);
		calAlterToMaxLH.copyExpectedNumbers(calBG);
		calAlterToMaxLH.addExpectedNumbers(1.0,calSignalTrial);
	    }

	    if(includeNuisance){
		testFactory.calNuisanceSignal.useTheResultsByTheRealExperiment();
		double maximizedSignalFactor = calAlterToMaxLH.getSignalFactor(1.0, testFactory.calNuisanceSignal);
		calAlterToMaxLH.addExpectedNumbers(maximizedSignalFactor,calNuisanceSignal);
	    }

	    if(!runReplicaExperiment)  calAlterToMaxLH.useTheResultsByTheRealExperiment();
	    else calAlterToMaxLH.useTheResultsByTheReplicaExperiment();

	    double llhAlter = calAlterToMaxLH.getLikelihood();

	    if(llhAlter <= llhSignalFloated){ // chech if it is minimum
		llhSignalFloated = llhAlter;
		calSignalToMaxLH = calSignalTrial;
	    }
	}
	double llhRatio = llhNull - llhSignalFloated;
	buildLLH = true;

	return llhRatio;

    }


    /**
       Return the PoissonBinnedLikelihoodCalculator to contain the model that maximized the poisson binned likelihood.
       Run getLLHRatio(boolean runReplicaExperiment) first to scan all the parameters for searching the maximal
       likelihood.
     */
    public PoissonBinnedLikelihoodCalculator getModelToMaximizeLH(){
	if(buildLLH){
	    return calSignalToMaxLH;
	}else{
	    System.err.println("You must run getLLHRatio(boolean runReplicaExperiment) first!");
	    return null;
	}
    }


    /** 
	Calculate collections of the log likelihhood ratio
        <pre> 
	alternative (calBG + model stored in calSignalSetsList (+ nuisance ) with parameters to maximize Likelihood)/
	null hypothesis(calBG + calSignal with a given neutrino parameter (+ nuisance to maximize likelihood))
	</pre>
	by running replica experiments.

    */
    public void makeCollectionOfLogLikelihoodRatio(int runTimes){

	llhRatioList = new LinkedList();
	boolean runReplicaExperiment = true;
	for(int run = 0 ;run<runTimes; run++){
	    double llhRatio =  getLLHRatio(runReplicaExperiment);
	    Double llhRatioObj = new Double(llhRatio);
	    llhRatioList.add(llhRatioObj);
	    System.out.format("  --runtime(%d) llhRatio=%e --\n", run,llhRatio);
	}

	// sort
	Collections.sort(llhRatioList);
	llhRatioListCreated = true;
    }



    /** 
	Calculate the p-value of the model parameters of calSignal. The test statstic is the lilelihood ratio
        <pre> 
	alternative (calBG + model stored in calSignalSetsList (+ nuisance ) with parameters to maximize Likelihood)/
	null hypothesis(calBG + calSignal with a given neutrino parameter (+ nuisance to maximize likelihood))
	</pre>
        The p.d.f. of the test statstic is simulated by calling the method makeCollectionOfLogLikelihoodRatio(runTimesDefault)
	internally. int trialTimes is the trail number to run the pseudo-experiments in the p-value calculation.
	The acuracy of p-value will be O(1/trialTimes).
    */
    public double getPvalue(double llhRatioObserved, int trialTimes){
	if(!llhRatioListCreated) makeCollectionOfLogLikelihoodRatio(trialTimes);
	ListIterator llhRatioListIterator = getllhRatioIterator();
	double significance = 1.0;
	int times = 0;
	int runTimes = llhRatioList.size();
	while(llhRatioListIterator.hasNext()){
	    times++;
	    Double llhRatioObj = (Double )(llhRatioListIterator.next());
	    double llhRatio = llhRatioObj.doubleValue();
	    double pValue = 1.0-((double )times)/((double )runTimes);
	    if(llhRatio< llhRatioObserved) significance = pValue;
	}

	return significance;
    }

    /** 
	Calculate the p-value of the model parameters of calSignal. The test statstic is the lilelihood ratio
        <pre> 
	alternative (calBG + model stored in calSignalSetsList (+ nuisance ) with parameters to maximize Likelihood)/
	null hypothesis(calBG + calSignal with a given neutrino parameter (+ nuisance to maximize likelihood))
	</pre>
        The p.d.f. of the test statstic is simulated by calling the method makeCollectionOfLogLikelihoodRatio(runTimesDefault)
	internally. int runTimes is the trail number to run the pseudo-experiments in the p-value calculation.
	The default runTime number is used in the p-value calculation.
    */
    public double getPvalue(double llhRatioObserved){
	return getPvalue(llhRatioObserved,runTimesDefault);
    }


    /** return the list iterator to access the signal poisson binned data 
	with various model parameters. */
    public ListIterator getSignalSetsListIterator(){
	return calSignalSetsList.listIterator();
    }


    /** return the list iterator to access the list container of the llhRatio data
	obtained by running replica experiments with the method  makeCollectionOfLogLikelihoodRatio() */
    public ListIterator getllhRatioIterator(){
	return llhRatioList.listIterator();
    }


    /** build the list to store PoissonBinnedLikelihoodCalculator calSignal with various model parameters 
     from Map(Key=PoissonBinnedLikelihoodCalculator).    It internally builds calSignalSetsList, the container 
     to store PoissonBinnedLikelihoodCalculator objects of the signal hypothesis but with all the parameter values allowd in their range.
     This is an utility method.
    */
    public void buildCalSignalSetsListFromMap(Map calSignalMap){
	calSignalSetsList = new LinkedList();
	Iterator dataIterator = calSignalMap.entrySet().iterator();
	while(dataIterator.hasNext()){
	    Map.Entry entryData = (Map.Entry )(dataIterator.next());
	    PoissonBinnedLikelihoodCalculator cal = (PoissonBinnedLikelihoodCalculator)(entryData.getKey());
	    calSignalSetsList.add(cal);
	}

    }


    /** A simple main method for debugging */
   public static void main(String[] args) throws IOException{

       Map calMap = null;
       List calList = null;
       String sigEventRateFileName = "./numRecipes/juliet12.Calliandra.data";
       String sigEventRateFileName2 = "./numRecipes/juliet13.case6.data";
       String bgEventRateFileName = "./numRecipes/bgsum.Calliandra.data";

       PoissonBinnedLikelihoodCalculator calBG = new PoissonBinnedLikelihoodCalculator();
       DataInputStream in = new DataInputStream(ClassLoader.getSystemResourceAsStream(bgEventRateFileName));
       calBG.fillData(in);
       in.close();

       PoissonBinnedLikelihoodCalculator calSignal12 = new PoissonBinnedLikelihoodCalculator();
       in = new DataInputStream(ClassLoader.getSystemResourceAsStream(sigEventRateFileName));
       calSignal12.fillData(in);
       in.close();

       PoissonBinnedLikelihoodCalculator calSignal13 = new PoissonBinnedLikelihoodCalculator();
       in = new DataInputStream(ClassLoader.getSystemResourceAsStream(sigEventRateFileName2));
       calSignal13.fillData(in);
       in.close();

       calMap = new LinkedHashMap();
       calMap.put(calBG,new Double(1.0));
       calMap.put(calSignal12,new Double(2.0));
       calMap.put(calSignal13,new Double(3.0));

       ModelParaPvalueCalculatorByPoissonBinnedLH pvalueCalculator = 
	   new ModelParaPvalueCalculatorByPoissonBinnedLH(calBG,calSignal13,calMap);

       boolean runReplicaExperiment = false;
       double llhRatioObserved = pvalueCalculator.getLLHRatio(runReplicaExperiment);
       PoissonBinnedLikelihoodCalculator modelToMaxLH =  pvalueCalculator.getModelToMaximizeLH();
       Double paraToMaxLH =  (Double )(calMap.get(modelToMaxLH));
       System.out.format(" model to max llh = %f llhRatioObserved = %e\n",paraToMaxLH.doubleValue(),llhRatioObserved);
       runReplicaExperiment = true;
       double llhRatioSimulated = pvalueCalculator.getLLHRatio(runReplicaExperiment);
       PoissonBinnedLikelihoodCalculator modelToMaxLHbyMC =  pvalueCalculator.getModelToMaximizeLH();
       paraToMaxLH =  (Double )(calMap.get(modelToMaxLHbyMC));
       System.out.format(" model to max llh = %f llhRatioSimulated = %e\n",paraToMaxLH.doubleValue(),llhRatioSimulated);
       //double pValue = pvalueCalculator.getPvalue(llhRatioObserved);
       //System.out.format(" pValue = %e\n",pValue);


    }


}