package iceCube.uhe.analysis;

import numRecipes.*;
import iceCube.uhe.analysis.*;
import java.io.*;
import java.util.*;

/**

   Calculate the p-value on a given neutrino model based on the binned Poisson likelihood. 
   The PoissonBinnedLikelihoodCalculator :
   <pre>
   PoissonBinnedLikelihoodCalculator  calBG     (for the atmospheric background)
   PoissonBinnedLikelihoodCalculator  calSinal   (for the neutrino model such as GZK to be tested)
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal (for the nuisance signal - like E^-2 against the GZK test) 
   </pre>
   are generated by the correponding binned data from the files and then executes the methods
   provied by ModelTestByPoissonBinnedLikelihoodFactory.


The likeliihood ratio type 2
  <pre> 
  2   alternative hypothesis(bg + model signal with floated normalization)/null hypothesis(bg + model signal (+ nuisance))
 </pre>
is used for the test-statstic

*/
public class ModelPvalueCalculatorByPoissonBinnedLikelihood {

    public static void main(String[] args) throws IOException{

        PoissonBinnedLikelihoodCalculator calBG = null;
        PoissonBinnedLikelihoodCalculator calSignal = null;
        PoissonBinnedLikelihoodCalculator calNuisanceSignal = null;
	ModelTestByPoissonBinnedLikelihoodFactory testFactory = null;
        boolean debugMode = false;
	boolean includeNuisance = false;
	boolean runReplicaExperiment = false;
	boolean DataIsMap = false;
	int likelihoodRatioType = 2;

        String sigEventRateFileName = null;
        String nuisanceSigEventRateFileName = null;
        String bgEventRateFileName = null;

        if(args.length<3){
            System.out.println("Usage: ModelPvalueCalculatorByPoissonBinnedLikelihood filename-to-read-BGdata filename-to-read-SIGdata DataIsMap(yes 1 no 0) (filename-E2-Map as nuisance)");
            System.exit(0);
        }else {
            bgEventRateFileName = args[0];
            sigEventRateFileName = args[1];
	    int index = Integer.valueOf(args[2]).intValue();
	    if(index == 1)  DataIsMap = true;
	    if(args.length==4){
		includeNuisance = true;
		nuisanceSigEventRateFileName = args[3];
		likelihoodRatioType = 6;
	    }
	}
	System.err.format(" likelihood ratio type = %d\n",likelihoodRatioType);
	if(DataIsMap) System.err.println(" Binned Data in Map format is read out");

        // BG : background-only hypothesis
	if(!DataIsMap){
	    calBG = new PoissonBinnedLikelihoodCalculator();
	    if(debugMode) calBG.debugFlag = true;
	    DataInputStream in = 
		new DataInputStream(ClassLoader.getSystemResourceAsStream(bgEventRateFileName));
	    calBG.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(bgEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    Map bgBinnedDataMap = null;
	    try{
		bgBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calBG = PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(bgBinnedDataMap);
	}

	// SIG : neutrino model to be tested
	if(!DataIsMap){
	    calSignal = new PoissonBinnedLikelihoodCalculator();
	    if(debugMode) calSignal.debugFlag = true;
	    DataInputStream in = 
		new DataInputStream(ClassLoader.getSystemResourceAsStream(sigEventRateFileName));
	    calSignal.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(sigEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    Map modelBinnedDataMap = null;
	    try{
		modelBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calSignal = 
		PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(modelBinnedDataMap);
	}

	// Nuisance Signal : an E^-2 unbroken is typical
	if(includeNuisance){
	    if(!DataIsMap){
		calNuisanceSignal = new PoissonBinnedLikelihoodCalculator();
		if(debugMode) calSignal.debugFlag = true;
		DataInputStream in = 
		    new DataInputStream(ClassLoader.getSystemResourceAsStream(nuisanceSigEventRateFileName));
		calNuisanceSignal.fillData(in);
		in.close();
	    }else{
		FileInputStream in = new FileInputStream(nuisanceSigEventRateFileName);
		ObjectInputStream objectIn = new ObjectInputStream(in);
		Map modelBinnedDataMap = null;
		try{
		    modelBinnedDataMap = (Map )objectIn.readObject();
		}catch(ClassNotFoundException e){
		    System.err.println("Caught ClassNotFoundException: " + 
				       e.getMessage( ));
		    System.exit(0);
		}
		in.close();
		calNuisanceSignal = 
		    PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(modelBinnedDataMap);
	    }
	    System.err.println(" included nuisance model");
	}

	if(!includeNuisance) testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal);
	else  testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal,calNuisanceSignal);
 
	//
	// the lilelihood of null hypothesis (model + bg)
	// fiest the real data
	runReplicaExperiment = false;
	double llhNull = testFactory.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	double llhSignalFloated = 0.0;
	double  maximizedFactor = 0.0;
	if(!includeNuisance){    
	    llhSignalFloated = testFactory.buildLikelihoodForAlternativeHypothesis(false,runReplicaExperiment);
	    maximizedFactor = testFactory.getModelNormalizationToMaximizeLikelihood();
	}else{
	    llhSignalFloated = testFactory.buildLikelihoodForHybridHypothesis(runReplicaExperiment);
	}


	System.out.format("llh Null = %e\n",llhNull);
	System.out.format("llh signal Floated = %e\n",llhSignalFloated);
	System.out.format("normalization to maximize llh = %e\n",maximizedFactor);

	double llhRatioObserved = llhNull-llhSignalFloated;
	System.out.format("llh Ratio = %e\n",llhRatioObserved);

	//
	// calculate the llhRatio distribution by running pseudo-experiments 
	//
	int runTimes = 500000;
	if(includeNuisance) runTimes = 1000;
	testFactory.makeCollectionOfLogLikelihoodRatio(likelihoodRatioType,runTimes);
	ListIterator llhRatioListIterator = testFactory.getllhRatioIterator();
	double significance = 1.0;
	int times = 0;
	while(llhRatioListIterator.hasNext()){
	    times++;
	    Double llhRatioObj = (Double )(llhRatioListIterator.next());
	    double llhRatio = llhRatioObj.doubleValue();
	    double pValue = 1.0-((double )times)/((double )runTimes);
	    if(llhRatio< llhRatioObserved) significance = pValue;
	}
	System.out.format("p-value %e\n",significance);


    }

   
}