package iceCube.uhe.analysis;

import numRecipes.*;
import iceCube.uhe.analysis.*;
import java.io.*;
import java.util.*;

/**

   Calculate the p-value on a given neutrino model based on the binned Poisson likelihood. 
   The PoissonBinnedLikelihoodCalculator :
   <pre>
   PoissonBinnedLikelihoodCalculator  calBG     (for the atmospheric background)
   PoissonBinnedLikelihoodCalculator  calSinal   (for the neutrino model such as GZK to be tested)
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal (for the nuisance signal - like E^-2 against the GZK test) 
   </pre>
   are generated by the correponding binned data from the files and then executes the methods
   provied by ModelTestByPoissonBinnedLikelihoodFactory.


The likeliihood ratio type 2
  <pre> 
  2   alternative hypothesis(bg + model signal with floated normalization)/null hypothesis(bg + model signal (+ nuisance))
 </pre>
is used for the test-statstic

*/
public class ModelNormalizationCalculatorByPoissonBinnedLikelihood {

    public static void main(String[] args) throws IOException{

	Map modelBinnedDataMap = null;
        PoissonBinnedLikelihoodCalculator calBG = null;
        PoissonBinnedLikelihoodCalculator calSignal = null;
        PoissonBinnedLikelihoodCalculator calNuisanceSignal = null;
	ModelTestByPoissonBinnedLikelihoodFactory testFactory = null;
        boolean debugMode = false;
	boolean includeNuisance = false;
	boolean runReplicaExperiment = false;
	int likelihoodRatioType = 2;

        String sigEventRateFileName = null;
        String nuisanceSigEventRateFileName = null;
        String bgEventRateFileName = null;

        if(args.length<2){
            System.out.println("Usage: ModelPvalueCalculatorByPoissonBinnedLikelihood filename-to-read-BGdata filename-to-read-SIGdata (filename-E2-Map as nuisance)");
            System.exit(0);
        }else {
            bgEventRateFileName = args[0];
            sigEventRateFileName = args[1];
	    if(args.length==3){
		includeNuisance = true;
		nuisanceSigEventRateFileName = args[2];
		likelihoodRatioType = 6;
	    }
	}
	System.err.format(" likelihood ratio type = %d\n",likelihoodRatioType);

        // BG : background-only hypothesis
	FileInputStream in = new FileInputStream(bgEventRateFileName);
	ObjectInputStream objectIn = new ObjectInputStream(in);
	Map bgBinnedDataMap = null;
	try{
	    bgBinnedDataMap = (Map )objectIn.readObject();
	}catch(ClassNotFoundException e){
	    System.err.println("Caught ClassNotFoundException: " + 
			       e.getMessage( ));
	    System.exit(0);
	}
	in.close();
	calBG = PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(bgBinnedDataMap);

	// Nuisance Signal : an E^-2 unbroken is typical
	if(includeNuisance){
	    in = new FileInputStream(nuisanceSigEventRateFileName);
	    objectIn = new ObjectInputStream(in);
	    modelBinnedDataMap = null;
	    try{
		modelBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calNuisanceSignal = 
		PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(modelBinnedDataMap);
	    System.err.println(" included nuisance model");
	}

	// SIG : neutrino model to be tested
	in = new FileInputStream(sigEventRateFileName);
	objectIn = new ObjectInputStream(in);
	modelBinnedDataMap = null;
	try{
	    modelBinnedDataMap = (Map )objectIn.readObject();
	}catch(ClassNotFoundException e){
	    System.err.println("Caught ClassNotFoundException: " + 
			       e.getMessage( ));
	    System.exit(0);
	}
	in.close();
	Iterator dataIterator = modelBinnedDataMap.entrySet().iterator();
	while(dataIterator.hasNext()){
	    Map.Entry entryData = (Map.Entry )(dataIterator.next());


	    calSignal = (PoissonBinnedLikelihoodCalculator)(entryData.getKey());
	    Map paraMap = (Map )(entryData.getValue());

	    System.out.println("===========================");
	    double mInThisModel = 0.0;
	    if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterEvolution)){
		Double mInThisModelObj =
		    (Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterEvolution);
		mInThisModel = mInThisModelObj.doubleValue();
		System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterEvolution);
		System.out.format(" = %f\n",mInThisModel);
	    }
	    double zmaxInThisModel = 0.0;
	    if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterRedshift)){
		Double zmaxInThisModelObj =
		    (Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterRedshift);
		zmaxInThisModel = zmaxInThisModelObj.doubleValue();
		System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterRedshift);
		System.out.format(" = %f\n",zmaxInThisModel);
	    }
	    double powerLawIndex = 0.0;
	    if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterPowerLawIndex)){
		Double powerLawIndexObj =
		    (Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterPowerLawIndex);
		powerLawIndex = powerLawIndexObj.doubleValue();
		System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterPowerLawIndex);
		System.out.format(" = %f\n",powerLawIndex);
	    }
	    double energyBase = 0.0;
	    if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterEnergyBase)){
		Double energyBaseObj =
		    (Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterEnergyBase);
		energyBase = energyBaseObj.doubleValue();
		System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterEnergyBase);
		System.out.format(" = %e\n",energyBase);
	    }
	    double eFlux = 0.0;
	    if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterEnergyFluxAtBase)){
		Double eFluxObj =
		    (Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterEnergyFluxAtBase);
		eFlux = eFluxObj.doubleValue();
		System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterEnergyFluxAtBase);
		System.out.format(" = %e\n",eFlux);
	    }
	    double cutoffEnergy = 0.0;
	    if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterCutoffEnergy)){
		Double cutoffEnergyObj =
		    (Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterCutoffEnergy);
		cutoffEnergy = cutoffEnergyObj.doubleValue();
		System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterCutoffEnergy);
		System.out.format(" = %e\n",cutoffEnergy);
	    }
	    System.out.println("===========================");


	
	    if(!includeNuisance) testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal);
	    else  testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal,calNuisanceSignal);
 
	    //
	    // the lilelihood of null hypothesis (model + bg)
	    // first the real data
	    runReplicaExperiment = false;
	    double llhNull = testFactory.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	    if(includeNuisance){
		System.out.format("nuisance normalization in null hypothesis = %e\n",
				  testFactory.getNuisanceNormalizationToMaximizeLikelihood());
	    }
		
	    double llhSignalFloated = 0.0;
	    double  maximizedSignalFactor = 0.0;
	    double  maximizedNuisanceFactor = 0.0;
	    if(!includeNuisance){    
		llhSignalFloated = testFactory.buildLikelihoodForAlternativeHypothesis(false,runReplicaExperiment);
		maximizedSignalFactor = testFactory.getModelNormalizationToMaximizeLikelihood();
	    }else{
		llhSignalFloated = testFactory.buildLikelihoodForHybridHypothesis(runReplicaExperiment);
		maximizedSignalFactor = testFactory.getModelNormalizationToMaximizeLikelihood();
		maximizedNuisanceFactor = testFactory.getNuisanceNormalizationToMaximizeLikelihood();
	    }


	    System.out.format("model normalization = %e\n",maximizedSignalFactor);
	    System.out.format("nuisance normalization = %e\n",maximizedNuisanceFactor);

	}

    }

   
}
