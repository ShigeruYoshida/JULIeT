package iceCube.uhe.analysis;

import iceCube.uhe.particles.*;
import iceCube.uhe.points.*;
import iceCube.uhe.interactions.*;
import iceCube.uhe.propagation.*;
import iceCube.uhe.analysis.*;

import java.io.*;
import java.util.*;

/**
   It calculates the detectable neutrino event intensity 
   at the Earth Surface as I3ParticleFlux does
   but the calculation is made by using directly 
   the zenith angle binned propagation matrix
   and the numerically calculated effective area (I3EffectiveArea.java)
   without relying on I3Particle MC events.

   This subclass read out the propagation matrix
   generated by PropagationMatrixBHevaporation.java
   in the propagation package adding the neutrino interaction
   channel via the micro black-hole creation.

   Written by S. Yoshida June 3 2009

*/

public class BHevapPropagationMatrixFlux extends PropagationMatrixFlux {

    protected InteractionsMatrix nuCCMtx = null; 
    private String nuCCMtxObjectFile = "ENeutrinoChargeMtx";
    protected InteractionsMatrix nuNCMtx = null; 
    private String nuNCMtxObjectFile = "ENeutrinoNeutralMtx";

    /** Whether consider the case of double muons/taus, and a pair of mu + tau.
	If false, then all the muons and taus consitiute an uncorrelated
	single track. This is valid when their multiplicity is lower than unity.
     */
    protected boolean considerMultiTracks = false;


    protected NeutrinoBHevaporation nuBH = null;

    protected static String[] intMtxPathname =
    {"iceCube/uhe/interactions/ice/","iceCube/uhe/interactions/rock/"};
    protected static String[] propMtxPathname =
    {"../data/propMtxBH/ice/","../data/propMtxBH/rock/"};
    protected int modelNumber;

    private static double epsilon = 1.0e-4; // round-off margin for binning
    private static final double ln10 = Math.log(10.0);

    /** constroctor */
    public BHevapPropagationMatrixFlux(int modelNumber) throws IOException{
	super();

	// The Charged Current neutrino-nucleon
	String objectFile = intMtxPathname[0].concat(nuCCMtxObjectFile);
	InputStream in = ClassLoader.getSystemResourceAsStream(objectFile);
	nuCCMtx = InteractionsMatrixInput.inputInteractionsMatrix(in);

	// The Neutral Current neutrino-nucleon
	objectFile = intMtxPathname[0].concat(nuNCMtxObjectFile);
	in = ClassLoader.getSystemResourceAsStream(objectFile);
	nuNCMtx = InteractionsMatrixInput.inputInteractionsMatrix(in);

	// The BH creation/evaporation channel
        Particle nu = new Particle(0, 0); // nuE
	ParticlePoint s = new ParticlePoint(0.0, 5.0*Math.PI/180.0,0);//ice
	nuBH = new NeutrinoBHevaporation(nu, s);
	nuBH.setModelNumber(modelNumber);
	this.modelNumber = modelNumber;

    }

    /** Calculate the neutrino yield [cm^2 sec sr] in form of the table
        by reasing out the pre-stored propagation matrix data
	via the PropagationMatrixFactory.
	A primary neutrino bulk is assumed to be consist of
	nu_e, nu_mu, nu_tau = 1:1:1.
    */
    public void calculateYield() throws IOException {

	if(inIceFlavorList.size()<1){ // nothing stored to specify the inIceParticles!
	    System.err.println(" You have to call setInIceParticle(flavor doublet) first!");
	    System.exit(0);
	}

	for(int i=0;i<Particle.getDimensionOfLogEnergyMatrix(); i++) 
	    yieldTable[i]=0.0;

	// Zenith Angle Loop
       for(int upDown=1;upDown<3;upDown++){
	   for(int itheta=0;itheta<I3ParticleWeightFiller.matrixFileName[upDown].length;
	       itheta++){

	       // Read the serialized object of the Neutrino Charged Interaction Matrix
	       String fileName = 
		   propMtxPathname[upDown%2] + 
		   I3ParticleWeightFiller.matrixFileName[upDown][itheta];
	       DataInputStream in = new DataInputStream(new FileInputStream(fileName));
	       matrix.readMatrix(in);
	       in.close( );
	       System.err.println("Reading the matrix from " + fileName + " done.");

	       // Solid angle calculation
	       double radiansUp = 0.0; double radiansDown = 0.0;
	       double cosZenith = 0.0;
	       if(upDown==1){ // rock
	          radiansUp = Math.toRadians(I3ParticleWeightFiller.rockrange[itheta]);
		  radiansDown = 
		      Math.toRadians(I3ParticleWeightFiller.rockrange[itheta+1]);
		  cosZenith = Math.cos(Math.PI-radiansUp); // nadir to Zenith
	       }else { // ice
	          radiansUp = Math.toRadians(I3ParticleWeightFiller.icerange[itheta]);
		  radiansDown = 
		      Math.toRadians(I3ParticleWeightFiller.icerange[itheta+1]);
		  cosZenith = Math.cos(radiansUp);
	       }
	       double solidAngle = 
		   2.0*Math.PI*Math.abs(Math.cos(radiansDown)-Math.cos(radiansUp));
	       System.err.println(" Solid angle " + solidAngle);


	       // Earth-surface Neutrino Energy loop
	       for(int iLogE = 0;iLogE<Particle.getDimensionOfLogEnergyMatrix();
		   iLogE++){

		   double logNuSurfaceEnergy = Particle.getLogEnergyMinimum()
		       + Particle.getDeltaLogEnergy()*((double )iLogE) + epsilon;

		   setNeutrinoSurfaceEnergy(logNuSurfaceEnergy);

		   // InIceParticle loop
		   ListIterator inIceFlavorIterator = inIceFlavorList.listIterator();
		   ListIterator inIceDoubletIterator = inIceDoubletList.listIterator();
		   ListIterator inIceAreaIterator = inIceAreaList.listIterator();
		   double flux = 0.0;
		   while(inIceFlavorIterator.hasNext()){
		       int inIceFlavor = 
			   ((Integer )inIceFlavorIterator.next()).intValue();
		       int inIceDoublet = 
			   ((Integer )inIceDoubletIterator.next()).intValue();

		       Particle iceParticle = new Particle(inIceFlavor,inIceDoublet);

		       EffAreaTable areaTable = (EffAreaTable )inIceAreaIterator.next();

		       // InIce Lepton Energy loop
		       for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
			   jLogE ++) {

			   double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;
			   iceParticle.putLogEnergy(logInIceEnergy);

			   // scaling for the case of neutrino 
			   // entering into the iceCube deep ice volume
			   double enhanceFactor = 1.0;
			   if(inIceDoublet==0){
			       double sigmaCC = nuCCMtx.getSigmaMatrix(jLogE);
			       double sigmaNC = nuNCMtx.getSigmaMatrix(jLogE);
			       nuBH.setIncidentParticleEnergy(jLogE);
			       double sigmaBH = nuBH.getSigma();
			       enhanceFactor = (sigmaNC+sigmaCC+sigmaBH)/(sigmaNC+sigmaCC);
			   }

			   double inIceParticleIntensity = 
			       matrix.getDF(nuE,iceParticle)+
			       matrix.getDF(nuMu,iceParticle)+
			       matrix.getDF(nuTau,iceParticle);

			   // The case of muons and taus. Their multiplicity
			   // is involved in the in-ice particle intensity
			   // as well as their total "effective" energy
			   // that determins the detector's effective area

			   if(inIceDoublet==1 && considerMultiTracks){  // charged lepton
			       double neutrinoEnergyAtSurface = 
				   Math.pow(10.0,logNuSurfaceEnergy);
			       nuBH.setIncidentParticleEnergy(neutrinoEnergyAtSurface);

			       inIceParticleIntensity = 
				   getIntensityOfMuAndTau(logInIceEnergy,inIceFlavor);
			       if(inIceFlavor == 2){ // tau
				   // a muon and a tau
				   inIceParticleIntensity += 
				       getIntensityOfMuAndTau(logInIceEnergy,3);
			       }

			   }

			   // effective area [cm^2]
			   double area = 
			       areaTable.getArea(logInIceEnergy,cosZenith)*1.0e10;
			   flux += enhanceFactor*area*inIceParticleIntensity;


		       }// loop over inIce Energy ends

		   }// loop over inIce Particle ends

		   yieldTable[iLogE] += flux*solidAngle*observationTime;

	       } // loop over Neutrino Energy ends

	   } // loop over Zenith Angle ends
       } // up and down

       yieldTableExists = true;

    }


    /**
       calculate the muon and tau fluxes after the propagation in the earth.
       The (uncorrelated) mu and tau intensites have been pre-calculated
       by the PropagationMatrix (generated by PropagationMatrixBHevaporation.java)
       and the calculation in this method relies on the matrix data, but
       it also consider the effects that muons and taus can be correlated
       (like "double" muons) in the BH evaporation scenario. This method,
       therefore, convolutes the matrix data of nu-> mu/tau with weights of 
       the multiplicities predicted by the BH model. For simplicity, 
       only the case of the multiplicity up to 2 (double muon, mu+tau etc)
       is considered. Because the average mu/tau multiplicity predicted by the model
       is mostly less than 1, this treatment is good enough.

       In order to get the results you need, you have to set the neutrino
       energy at the earth surface to the object members Particle nuE,nuMu,nuTau,
       and new NeutrinoBHevaporation nuBH. The utlity method 
       setNeutrinoSurfaceEnergy(double logEnergy) does this job for you.

       <pre>
       double logInIceEnergy  : log(Energy [GeV] at the I3 depth)
                                Energy is defined as total energy of muons
                                in case of multiple leptons
       int finalStateFlavor   : 1 (mu only) 2 (tau only) 3 (a mu plus a tau) 
       int multiplicityOfTrack: 1 (single) 2 (double) 3 (adds both - default)
       </pre>

     */
    protected double getIntensityOfMuAndTau(double logInIceEnergy,
					    int finalStateFlavor,
					    int multiplicityOfTrack){

	double inIceEnergy = Math.pow(10.0,logInIceEnergy+epsilon);

	double muMultiplicityAverage = nuBH.getMuonMultiplicity();
	double tauMultiplicityAverage = nuBH.getTauMultiplicity();
	double intensity = 0.0;

	// Case A  -- a single muon or a single tau
	if(finalStateFlavor!=3){

	    int multiplicity = 1;
	    double poissonProb = 0.0;
	    double normalization = 1.0;
	    Particle inIceParticle = null;

	    if(finalStateFlavor == 1){ // a single mu

		poissonProb = 
		    numRecipes.SpecialFunctions.poisson(muMultiplicityAverage,
							multiplicity)*
		    numRecipes.SpecialFunctions.poisson(tauMultiplicityAverage,
							0);
		normalization = poissonProb/muMultiplicityAverage;

	    }else if(finalStateFlavor == 2){ // a single tau

		poissonProb = 
		    numRecipes.SpecialFunctions.poisson(tauMultiplicityAverage,
							multiplicity)*
		    numRecipes.SpecialFunctions.poisson(muMultiplicityAverage,
							0);
		normalization = poissonProb/tauMultiplicityAverage;
	    }
	    else{ // illeagal setting. finalState must be either, 0,1,2.
		System.err.println("finalState you set " + finalStateFlavor +
				   " is out of range");
		return 0.0;
	    }

	    // this is a mu or tau
	    inIceParticle = new Particle(finalStateFlavor,1,inIceEnergy);

	    //System.err.println("  now calculate a single " + 
	    //		       inIceParticle.particleName(inIceParticle.getFlavor(),
	    //					inIceParticle.getDoublet()) +
	    //		       " with log(E) of" + inIceParticle.getLogEnergy());

	    inIceParticle.putLogEnergy(logInIceEnergy);
	    if(multiplicityOfTrack == 1 || multiplicityOfTrack == 3)
	    intensity += (matrix.getDF(nuE,inIceParticle)+
	    	  matrix.getDF(nuMu,inIceParticle)+
	    	  matrix.getDF(nuTau,inIceParticle))*normalization;


	// Case B  -- mutiple muons or multiple taus
	    
	    multiplicity = 2;
	    if(finalStateFlavor == 1){ // double mu
		poissonProb = 
		    numRecipes.SpecialFunctions.poisson(muMultiplicityAverage,
							multiplicity)*
		    numRecipes.SpecialFunctions.poisson(tauMultiplicityAverage,
							0);
		normalization = poissonProb/muMultiplicityAverage;

	    }else if(finalStateFlavor == 2){ // double tau
		poissonProb = 
		    numRecipes.SpecialFunctions.poisson(tauMultiplicityAverage,
							multiplicity)*
		    numRecipes.SpecialFunctions.poisson(muMultiplicityAverage,
							0);
		normalization = poissonProb/tauMultiplicityAverage;

	    }

	    Particle inIceParticle2 = new Particle(inIceParticle.getFlavor(),
						   inIceParticle.getDoublet(),
						   inIceParticle.getEnergy());

	    if(multiplicityOfTrack == 2 || multiplicityOfTrack == 3)
	    intensity += getConvolutedMatrix(logInIceEnergy, 
					     inIceParticle, 
					     inIceParticle2)*normalization;

	}else{ // Case C -- a muon + a tau

	    double poissonProb = 
		numRecipes.SpecialFunctions.poisson(tauMultiplicityAverage,
						    1)*
		numRecipes.SpecialFunctions.poisson(muMultiplicityAverage,
						    1);
	    double normalization = poissonProb/tauMultiplicityAverage;

	    Particle muon = new Particle(1,1,inIceEnergy);
	    Particle tau = new Particle(2,1,inIceEnergy);

	    intensity += getConvolutedMatrix(logInIceEnergy,muon,tau)*normalization;
	}

	return intensity;

    }

    protected double getIntensityOfMuAndTau(double logInIceEnergy,
					    int finalStateFlavor){

	return getIntensityOfMuAndTau(logInIceEnergy,finalStateFlavor,3);
    }




    protected void setNeutrinoSurfaceEnergy(double logNuSurfaceEnergy){
	nuE.putLogEnergy(logNuSurfaceEnergy);
	nuMu.putLogEnergy(logNuSurfaceEnergy);
	nuTau.putLogEnergy(logNuSurfaceEnergy);
	double neutrinoEnergyAtSurface = Math.pow(10.0,logNuSurfaceEnergy);
	nuE.putEnergy(neutrinoEnergyAtSurface);
	nuMu.putEnergy(neutrinoEnergyAtSurface);
	nuTau.putEnergy(neutrinoEnergyAtSurface);
	nuBH.setIncidentParticleEnergy(neutrinoEnergyAtSurface);
    }


    /**
       This method convolutes two propagation matrices
       of paricle 1 and particle 2 for calculating the intensity
       of two in-ice particles that carries total energy of 
       10**logInIceEnergy [GeV].
     */
    private double getConvolutedMatrix(double logInIceEnergy,
				       Particle particle1,
				       Particle particle2){


	double inIceEnergy = Math.pow(10.0,logInIceEnergy);
	double matrixConvSum = 0.0;

	for(int nuFlavor = 0; nuFlavor<3; nuFlavor++){

	    Particle nu = null;
	    if(nuFlavor == 0) nu = nuE;
	    else if(nuFlavor == 1) nu = nuMu;
	    else nu = nuTau;

	    double matrixSum1 = 0.0;
	    for(int iLogE = 0;iLogE< Particle.getDimensionOfLogEnergyMatrix();
		iLogE++){
		double logLeptonEnergy = Particle.getLogEnergyMinimum()+epsilon+
		    Particle.getDeltaLogEnergy()*(double )iLogE;
		particle1.putLogEnergy(logLeptonEnergy);
		matrixSum1 += matrix.getDF(nu,particle1);
	    }
	    //System.err.println("matrix sum from " + 
	    //		       Particle.particleName(nu.getFlavor(),
	    //					     nu.getDoublet()) +
	    //		       " with log(E)= "
	    //		       + nu.getLogEnergy() + " to " +
	    //		       Particle.particleName(particle1.getFlavor(),
	    //					     particle1.getDoublet()) +
	    //		       " = " + matrixSum1);


	    int iLogInIceE = (int)((logInIceEnergy+epsilon-
				    Particle.getLogEnergyMinimum())
				   /Particle.getDeltaLogEnergy());

	    int iStart = 0;
	    int iEnd =  Particle.getDimensionOfLogEnergyMatrix()-1;
	    if(logInIceEnergy<=nu.getLogEnergy()){ // Einice < Emax = Enu
		iStart = 0;
		iEnd = iLogInIceE;
	    }else{  // Emax < Einice  
		double logEend=nu.getLogEnergy();
		iEnd = (int)((logEend+epsilon-
			      Particle.getLogEnergyMinimum())
			     /Particle.getDeltaLogEnergy());
		double eStart = inIceEnergy-nu.getEnergy();
		if(eStart>0.0){
		    double logEstart=Math.log(eStart)/ln10;
		    iStart = (int)((logEstart+epsilon-
				    Particle.getLogEnergyMinimum())
				   /Particle.getDeltaLogEnergy());
		    if(iStart<0) iStart = 0;
		}else{
		    iStart = 0;
		}
	    }

	    double matrixConv = 0.0;
	    for(int iLogE1 = iStart; iLogE1<=iEnd; iLogE1++){
		double logE1 = Particle.getLogEnergyMinimum() +
		    Particle.getDeltaLogEnergy()*((double )iLogE1)+epsilon;
		particle1.putLogEnergy(logE1);

		double energy1 = Math.pow(10.0,logE1);
		double energy2 = inIceEnergy - energy1;
		double logE2 = Particle.getLogEnergyMinimum();
		if(energy2>0.0){
		    logE2 = Math.log(energy2)/ln10;
		}
		particle2.putLogEnergy(logE2);

		//System.err.println("  Energy1=" + energy1 + " Energy2=" + energy2);

		if(energy2>0.0) 
		    matrixConv += matrix.getDF(nu,particle1)*matrix.getDF(nu,particle2)
			/energy2;

	    }
	    matrixConv = matrixConv*inIceEnergy/matrixSum1;

	    matrixConvSum += matrixConv;
	}

	return matrixConvSum;
    }

    /**
       This is a method for debugging. Return 
       integral F_mu+tau(logNuEnergyAtSurface, logE)dLogE

       fileName is the propagation matrix file name to be used
       in calculation of the in-ice mu and tau spectrum induced
       from neutrinos with log(E)= logNuEnergyAtSurface.
     */
    protected double getIntegralIntensityOfMuAndTau(double logNuEnergyAtSurface,
						    String fileName) 
	throws IOException{

	setNeutrinoSurfaceEnergy(logNuEnergyAtSurface);

	// Read the serialized object of the Neutrino Charged Interaction Matrix
	DataInputStream in = new DataInputStream(new FileInputStream(fileName));
	matrix.readMatrix(in);
	in.close( );
	System.err.println("Reading the matrix from " + fileName + " done.");
	System.err.println("muon multiplicity " + nuBH.getMuonMultiplicity());

	// in-ice Particles
	Particle muon = new Particle(1,1);
	Particle tau = new Particle(2,1);

	double intensity = 0.0;
	// InIce Lepton Energy loop
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;
	    muon.putLogEnergy(logInIceEnergy);
	    tau.putLogEnergy(logInIceEnergy);
	    double intensityFromThisInIceEnergy = 0.0;

	    if(!considerMultiTracks){  // just return the average intensity
		intensityFromThisInIceEnergy =
		    matrix.getDF(nuE,muon)+matrix.getDF(nuE,tau)+
		    matrix.getDF(nuMu,muon)+matrix.getDF(nuMu,tau)+
		    matrix.getDF(nuTau,muon)+matrix.getDF(nuTau,tau);
	    }else {  // condier a single and a double tracks

		intensityFromThisInIceEnergy = 
		    getIntensityOfMuAndTau(logInIceEnergy,1)+
		    getIntensityOfMuAndTau(logInIceEnergy,2)+
		    getIntensityOfMuAndTau(logInIceEnergy,3);
	    }
	    intensity += intensityFromThisInIceEnergy;

	    //System.err.format("logEnu= %5.2f logEinice= %5.2f intensity=%8.4e\n",
	    //		      logNuEnergyAtSurface,logInIceEnergy,
	    //		      intensityFromThisInIceEnergy);
	}

	return intensity;
    }


    /**
       a simple main function for debugging this class
    */
    public static void main(String[] args) throws IOException{

	double logNuEnergyAtSurface = 6.0;
	String matrixName = null;
	int modelNumber=0;

        if(args.length!=2){
            System.out.println("Usage: BHevapPropagationMatrixFlux logEnuAtSurface matrix-file-name");
            System.exit(0);
        }else{
            logNuEnergyAtSurface = Double.valueOf(args[0]).doubleValue();
            matrixName = args[1];
        }


        BHevapPropagationMatrixFlux iceFlux = 
	    new BHevapPropagationMatrixFlux(modelNumber);

	double intensity = iceFlux.getIntegralIntensityOfMuAndTau(logNuEnergyAtSurface,
								  matrixName);
	System.err.format("logEnu = %5.2f intensity = %e\n",
			  logNuEnergyAtSurface,intensity);

	iceFlux.considerMultiTracks = true;
	intensity = iceFlux.getIntegralIntensityOfMuAndTau(logNuEnergyAtSurface,
								  matrixName);

	System.err.format("logEnu = %5.2f intensity = %e\n",
			  logNuEnergyAtSurface,intensity);


	System.out.println("titx log(Lepton Energy[GeV])");
	System.out.println("tity log(Flux)");

	// muon Energy Distribution (average)
	// InIce Lepton Energy loop
	System.out.println("hicl 4"); // red
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

		intensity =
		    iceFlux.matrix.getDF(iceFlux.nuE.getFlavor(),iceFlux.nuE.getDoublet(),
		    			 iceFlux.nuE.getLogEnergy(),
					 1,1,logInIceEnergy)+
		    iceFlux.matrix.getDF(iceFlux.nuMu.getFlavor(),iceFlux.nuMu.getDoublet(),
		    			 iceFlux.nuMu.getLogEnergy(),
					 1,1,logInIceEnergy)+
		    iceFlux.matrix.getDF(iceFlux.nuTau.getFlavor(),iceFlux.nuTau.getDoublet(),
		    			 iceFlux.nuTau.getLogEnergy(),
		    			 1,1,logInIceEnergy);
		double logIntensity = -15.0;
		if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
		System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");


	// tau Energy Distribution (average)
	// InIce Lepton Energy loop
	System.out.println("hicl 1"); // blue
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

		intensity =
		    iceFlux.matrix.getDF(iceFlux.nuE.getFlavor(),iceFlux.nuE.getDoublet(),
		    			 iceFlux.nuE.getLogEnergy(),
					 2,1,logInIceEnergy)+
		    iceFlux.matrix.getDF(iceFlux.nuMu.getFlavor(),iceFlux.nuMu.getDoublet(),
		    			 iceFlux.nuMu.getLogEnergy(),
					 2,1,logInIceEnergy)+
		    iceFlux.matrix.getDF(iceFlux.nuTau.getFlavor(),iceFlux.nuTau.getDoublet(),
		    			 iceFlux.nuTau.getLogEnergy(),
		    			 2,1,logInIceEnergy);
		double logIntensity = -15.0;
		if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
		System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");

	//  a single muon Energy Distribution
	// InIce Lepton Energy loop
	System.out.println("hicl 19"); //  dark red
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

	    intensity = iceFlux.getIntensityOfMuAndTau(logInIceEnergy,1,1);
	    double logIntensity = -15.0;
	    if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
	    System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");

	//  a double muon Energy Distribution
	// InIce Lepton Energy loop
	System.out.println("hicl 18"); //  dark red
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

	    intensity = iceFlux.getIntensityOfMuAndTau(logInIceEnergy,1,2);
	    double logIntensity = -15.0;
	    if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
	    System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");


	//  a single tau Energy Distribution
	// InIce Lepton Energy loop
	System.out.println("hicl 9"); //  dark blue
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

	    intensity = iceFlux.getIntensityOfMuAndTau(logInIceEnergy,2,1);
	    double logIntensity = -15.0;
	    if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
	    System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");

	//  a double tau Energy Distribution
	// InIce Lepton Energy loop
	System.out.println("hicl 8"); //  dark blue
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

	    intensity = iceFlux.getIntensityOfMuAndTau(logInIceEnergy,2,2);
	    double logIntensity = -15.0;
	    if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
	    System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");

	//  a mu + tau Energy Distribution
	// InIce Lepton Energy loop
	System.out.println("hicl 12"); //  dark green
	System.out.println("hfil -1");
	for(int jLogE= 0;jLogE<Particle.getDimensionOfLogEnergyMatrix();
	    jLogE ++) {

	    double logInIceEnergy = Particle.getLogEnergyMinimum()
			       + Particle.getDeltaLogEnergy()*((double )jLogE)+epsilon;

	    intensity = iceFlux.getIntensityOfMuAndTau(logInIceEnergy,3);
	    double logIntensity = -15.0;
	    if(intensity>0.0) logIntensity = Math.log(intensity)/ln10;
	    System.out.format("data %5.2f 0.0 %8.4f\n",logInIceEnergy-epsilon,logIntensity);
	}
	System.out.println("hist");
	System.out.println("disp");

	System.out.println("endg");
    }
}


