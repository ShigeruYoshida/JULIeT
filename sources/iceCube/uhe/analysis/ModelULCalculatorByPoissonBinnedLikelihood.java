package iceCube.uhe.analysis;

import numRecipes.*;
import iceCube.uhe.analysis.*;
import java.io.*;
import java.util.*;

/**

   Calculate the upper limit of normalization on a given neutrino model based on the binned Poisson likelihood. 
   The PoissonBinnedLikelihoodCalculator :
   <pre>
   PoissonBinnedLikelihoodCalculator  calBG     (for the atmospheric background)
   PoissonBinnedLikelihoodCalculator  calSinal   (for the neutrino model such as GZK to be tested)
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal (for the nuisance signal - like E^-2 against the GZK test) 
   </pre>
   are generated by the correponding binned data from the files and then executes the methods
   provied by ModelTestByPoissonBinnedLikelihoodFactory. 

   This class is used for settinng the model-independent differental limit or the model rejection factor.


The likeliihood ratio type 2
  <pre> 
  2   alternative hypothesis(bg + model signal with floated normalization)/null hypothesis(bg + model signal (+ nuisance))
 </pre>
is used for the test-statstic

*/
public class ModelULCalculatorByPoissonBinnedLikelihood {

    protected static int likelihoodRatioType = 2;
    private static boolean includeNuisance = false;
    private static boolean accelerated = false;
    protected static double confidenceLevel = 0.90; // 90% C.L. default
    protected static double nuisanceMultiplier = 1.0;
    protected static double epsilon = 1.0e-5; // round off

    protected static PoissonBinnedLikelihoodCalculator calBG = null;
    protected static PoissonBinnedLikelihoodCalculator calSignal = null;
    protected static PoissonBinnedLikelihoodCalculator calNuisanceSignal = null;
    protected static ModelTestByPoissonBinnedLikelihoodFactory testFactory = null;

    protected static boolean doNOTfloatNuisanceInNullHypothesis = false;
    /** A fixed fraction of the nuisance signal fitted by the data is used in
        the UL calculation, instead of using  the bestfit nuisance signal itself,
        in the null hypoethesis  */
    protected static boolean useFractionOfBestFitNuisanceSignal = false;
    protected static boolean conditioning = false;


    protected static void calculateUpperLimit(){

	if(!includeNuisance) testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal);
	else  testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal,calNuisanceSignal);
 
	//
	// the lilelihood of null hypothesis (model + bg)
	// fiest the real data
	boolean runReplicaExperiment = false;
	if(doNOTfloatNuisanceInNullHypothesis) testFactory.doNotFloatNuisanceInNullHypothesis();
	double llhNull = testFactory.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	double  maximizedFactor = 0.0;	
	double  maximizedNuisanceFactorNull = testFactory.getNuisanceNormalizationToMaximizeLikelihood();
	double  maximizedNuisanceFactor = 0.0;
	double llhSignalFloated = 0.0;
	if(!includeNuisance){    
	    llhSignalFloated = testFactory.buildLikelihoodForAlternativeHypothesis(false,runReplicaExperiment);
	    maximizedFactor = testFactory.getModelNormalizationToMaximizeLikelihood();
	}else{
	    llhSignalFloated = testFactory.buildLikelihoodForHybridHypothesis(runReplicaExperiment);
	    maximizedFactor = testFactory.getModelNormalizationToMaximizeLikelihood();
	    maximizedNuisanceFactor = testFactory.getNuisanceNormalizationToMaximizeLikelihood();
	}

	System.err.format("llh Null = %e\n",llhNull);
	System.err.format("llh signal Floated = %e\n",llhSignalFloated);
	System.err.format("normalization to maximize llh = %e\n",maximizedFactor);
	if(includeNuisance) System.err.format("nuisance normalization to maximize llh = %e\n",maximizedNuisanceFactor);


	double llhRatioObserved = llhNull-llhSignalFloated;
	System.err.format("llh Ratio = %e\n",llhRatioObserved);

	// 
	// The pre run to estimate the upper limit
	//
	double observedNumber = calBG.getSumOfObservedValues();
	double expectedNumberSignal = calSignal.getSumOfExpectedValues();
	double expectedNumberBG = calBG.getSumOfExpectedValues();
	if(includeNuisance) expectedNumberBG = calBG.getSumOfExpectedValues() + 
			calNuisanceSignal.getSumOfExpectedValues()*nuisanceMultiplier*maximizedNuisanceFactorNull;
	System.err.format("obs(%f) expectedSignal(%e) expectedBG(%e)\n",
			  observedNumber,expectedNumberSignal,expectedNumberBG);
	double multipleFactor = (observedNumber-expectedNumberBG)/expectedNumberSignal;
	if(multipleFactor<=0.0) multipleFactor = epsilon;

	//double multipleFactor =  maximizedFactor;
	double deltaFactor = 0.25;
	//double deltaFactor = 500.0;
	if(multipleFactor <= 0.1 ) deltaFactor = 0.1;
	if((!includeNuisance) && multipleFactor <= 0.07 ) deltaFactor = 0.02;
	multipleFactor -= deltaFactor;
	double significance = 1.0;
	int runTimes = 1000;
	if(includeNuisance) runTimes = 100;
	while(significance>(1.0-confidenceLevel)){ // 90 % C.L.
	    multipleFactor += deltaFactor;
	    PoissonBinnedLikelihoodCalculator calSignalFloated = new PoissonBinnedLikelihoodCalculator();
	    calSignalFloated.useTheResultsByTheRealExperiment();
	    calSignal.useTheResultsByTheRealExperiment();
	    calSignalFloated.copyPoissonBinnedData(calSignal);
	    calSignalFloated.copyExpectedNumbers(multipleFactor,calSignal);
	    ModelTestByPoissonBinnedLikelihoodFactory testFactoryForUpperSignal = null;
	    if(!includeNuisance) testFactoryForUpperSignal = 
				     new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated);
	    else testFactoryForUpperSignal = 
		     new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated, calNuisanceSignal);

	    runReplicaExperiment = false;
	    if(doNOTfloatNuisanceInNullHypothesis) testFactoryForUpperSignal.doNotFloatNuisanceInNullHypothesis();
	    llhNull = testFactoryForUpperSignal.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	    if(includeNuisance) maximizedNuisanceFactor = 
				    testFactoryForUpperSignal.getNuisanceNormalizationToMaximizeLikelihood();
	    if(!includeNuisance){    
		llhSignalFloated = 
		    testFactoryForUpperSignal.buildLikelihoodForAlternativeHypothesis(false,runReplicaExperiment);
	    }else{
		llhSignalFloated = 
		    testFactoryForUpperSignal.buildLikelihoodForHybridHypothesis(runReplicaExperiment);
	    }
	    maximizedFactor = testFactoryForUpperSignal.getModelNormalizationToMaximizeLikelihood();
	    llhRatioObserved = llhNull-llhSignalFloated;
	    //System.err.format("-----muliple factor = %e\n",multipleFactor);
	    //System.err.format("llh Null = %e\n",llhNull);
	    //System.err.format("llh signal Floated = %e\n",llhSignalFloated);
	    //System.err.format("normalization to maximize llh = %e\n",maximizedFactor);
	    //System.err.format("llh Ratio = %e\n",llhRatioObserved);

	    if(conditioning) testFactoryForUpperSignal.doConditioning(llhNull);
	    if(useFractionOfBestFitNuisanceSignal && includeNuisance){
		testFactoryForUpperSignal = null;
		testFactoryForUpperSignal =  
		    new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated, calNuisanceSignal);
		testFactoryForUpperSignal.doNotFloatNuisanceInNullHypothesis();
		testFactoryForUpperSignal.nuisanceSignalFixedMultiplier = nuisanceMultiplier*maximizedNuisanceFactor;
		llhNull = testFactoryForUpperSignal.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	    }
	    testFactoryForUpperSignal.makeCollectionOfLogLikelihoodRatio(likelihoodRatioType,runTimes);
	    ListIterator llhRatioListIterator = testFactoryForUpperSignal.getllhRatioIterator();
	    int times = 0;
	    while(llhRatioListIterator.hasNext()){
		times++;
		Double llhRatioObj = (Double )(llhRatioListIterator.next());
		double llhRatio = llhRatioObj.doubleValue();
		double pValue = 1.0-((double )times)/((double )runTimes);
		if(llhRatio< llhRatioObserved) significance = pValue;
	    }
	    System.err.format("multiple factor(%f) observed rate (%d) expected rate (%f) llh-ratio(%e) p-value(%f)\n",
			      multipleFactor,calSignalFloated.getSumOfObservedValues(),
			      calSignalFloated.getSumOfExpectedValues(),llhRatioObserved,significance);

	    if(significance>2.0*(1.0-confidenceLevel)){ // too far way to reach to the confidenceLevel region
		if(!accelerated){
		    deltaFactor = 2.0*deltaFactor;
		    runTimes = 50;
		}
		accelerated = true;
	    }else if(accelerated){
		deltaFactor = 0.5*deltaFactor;
		runTimes = 100;
		accelerated = false;
	    }


	}
	double initialGuessOfMultipleFactor = multipleFactor - 1.0*deltaFactor;
	if(initialGuessOfMultipleFactor<0.0) initialGuessOfMultipleFactor = 0.0;
	//if(initialGuessOfMultipleFactor<= maximizedFactor) 
	//    initialGuessOfMultipleFactor = maximizedFactor;

	// 
	// The main run to estimate the upper limit
	//
	multipleFactor = initialGuessOfMultipleFactor;
	deltaFactor = 0.01;
	//deltaFactor = 20.0;
	significance = 1.0;
	runTimes = 10000;
	//if(includeNuisance) runTimes = 300;
	if(includeNuisance) runTimes = 500;
	while(significance>(1.0-confidenceLevel)){ // 90 % C.L.
	    multipleFactor += deltaFactor;
	    PoissonBinnedLikelihoodCalculator calSignalFloated = new PoissonBinnedLikelihoodCalculator();
	    calSignalFloated.useTheResultsByTheRealExperiment();
	    calSignal.useTheResultsByTheRealExperiment();
	    calSignalFloated.copyPoissonBinnedData(calSignal);
	    calSignalFloated.copyExpectedNumbers(multipleFactor,calSignal);
	    ModelTestByPoissonBinnedLikelihoodFactory testFactoryForUpperSignal = null;
	    if(!includeNuisance) testFactoryForUpperSignal = 
				     new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated);
	    else testFactoryForUpperSignal = 
		     new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated, calNuisanceSignal);

	    runReplicaExperiment = false;
	    if(doNOTfloatNuisanceInNullHypothesis) testFactoryForUpperSignal.doNotFloatNuisanceInNullHypothesis();
	    llhNull = testFactoryForUpperSignal.buildLikelihoodForNullHypothesis(runReplicaExperiment);

	    if(includeNuisance)	maximizedNuisanceFactor = 
				    testFactoryForUpperSignal.getNuisanceNormalizationToMaximizeLikelihood();
	    
	    if(!includeNuisance){    
		llhSignalFloated = 
		    testFactoryForUpperSignal.buildLikelihoodForAlternativeHypothesis(false,runReplicaExperiment);
	    }else{
		llhSignalFloated = 
		    testFactoryForUpperSignal.buildLikelihoodForHybridHypothesis(runReplicaExperiment);
	    }
	    maximizedFactor = testFactoryForUpperSignal.getModelNormalizationToMaximizeLikelihood();
	    llhRatioObserved = llhNull-llhSignalFloated;

	    if(conditioning) testFactoryForUpperSignal.doConditioning(llhNull);
	    if(useFractionOfBestFitNuisanceSignal && includeNuisance){
		testFactoryForUpperSignal = null;
		testFactoryForUpperSignal =  
		    new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated, calNuisanceSignal);
		testFactoryForUpperSignal.doNotFloatNuisanceInNullHypothesis();
		testFactoryForUpperSignal.nuisanceSignalFixedMultiplier = nuisanceMultiplier*maximizedNuisanceFactor;
		llhNull = testFactoryForUpperSignal.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	    }
	    testFactoryForUpperSignal.makeCollectionOfLogLikelihoodRatio(likelihoodRatioType,runTimes);
	    ListIterator llhRatioListIterator = testFactoryForUpperSignal.getllhRatioIterator();
	    int times = 0;
	    while(llhRatioListIterator.hasNext()){
		times++;
		Double llhRatioObj = (Double )(llhRatioListIterator.next());
		double llhRatio = llhRatioObj.doubleValue();
		double pValue = 1.0-((double )times)/((double )runTimes);
		if(llhRatio< llhRatioObserved) significance = pValue;
	    }
	    System.err.format("multiple factor(%f) observed rate (%d) expected rate (%f) llh-ratio(%e) p-value(%f)\n",
			      multipleFactor,calSignalFloated.getSumOfObservedValues(),
			      calSignalFloated.getSumOfExpectedValues(),llhRatioObserved,significance);
	}

	System.out.format("UL %e\n",multipleFactor);
    }

    public static void main(String[] args) throws IOException{

	Map modelBinnedDataMap = null;
	boolean DataIsMap = false;

        String sigEventRateFileName = null;
        String nuisanceSigEventRateFileName = null;
        String bgEventRateFileName = null;

        if(args.length<3){
            System.out.println("Usage: ModelULCalculatorByPoissonBinnedLikelihood filename-to-read-BGdata filename-to-read-SIGdata DataIsMap(yes 1 no 0) (filename-E2-Map as nuisance) (1 -nuisance is NOT floated in null hypothesis 2- conditioning 3- fixed multiplier to nuisance) (nuisanceMultiplier)");
            System.exit(0);
        }else {
            bgEventRateFileName = args[0];
            sigEventRateFileName = args[1];
	    int index = Integer.valueOf(args[2]).intValue();
	    if(index == 1)  DataIsMap = true;
	    if(args.length>=4){
		includeNuisance = true;
		nuisanceSigEventRateFileName = args[3];
		likelihoodRatioType = 6;

		if(args.length >= 5){
		    int index2 = Integer.valueOf(args[4]).intValue();
		    if(index2 == 1){
			doNOTfloatNuisanceInNullHypothesis = true;
			System.err.println("  nuisance is NOT floated in the null hypothesis");
		    }else if (index2 == 2){
			conditioning = true;
			System.err.println("  conditioning is applied in replica-experiments of the null hypothesis");
		    }else if (index2 == 3){
			useFractionOfBestFitNuisanceSignal = true;
			nuisanceMultiplier = Double.valueOf(args[5]).doubleValue();
			System.err.format("  the bestfit nuisance flux multiplied by %f is used in the null hypothesis",
					  nuisanceMultiplier);
		    }
		}

	    }
	}
	System.err.format(" likelihood ratio type = %d\n",likelihoodRatioType);
	if(DataIsMap) System.err.println(" Binned Data in Map format is read out");

        // BG : background-only hypothesis
	if(!DataIsMap){
	    calBG = new PoissonBinnedLikelihoodCalculator();
	    DataInputStream in = 
		//new DataInputStream(ClassLoader.getSystemResourceAsStream(bgEventRateFileName));
		new DataInputStream(new FileInputStream(bgEventRateFileName));
	    calBG.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(bgEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    Map bgBinnedDataMap = null;
	    try{
		bgBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calBG = PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(bgBinnedDataMap);
	}

	// Nuisance Signal : an E^-2 unbroken is typical
	if(includeNuisance){
	    if(!DataIsMap){
		calNuisanceSignal = new PoissonBinnedLikelihoodCalculator();
		DataInputStream in = 
		    //new DataInputStream(ClassLoader.getSystemResourceAsStream(nuisanceSigEventRateFileName));
		    new DataInputStream(new FileInputStream(nuisanceSigEventRateFileName));
		calNuisanceSignal.fillData(in);
		in.close();
	    }else{
		FileInputStream in = new FileInputStream(nuisanceSigEventRateFileName);
		ObjectInputStream objectIn = new ObjectInputStream(in);
		try{
		    modelBinnedDataMap = (Map )objectIn.readObject();
		}catch(ClassNotFoundException e){
		    System.err.println("Caught ClassNotFoundException: " + 
				       e.getMessage( ));
		    System.exit(0);
		}
		in.close();
		calNuisanceSignal = 
		    PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(modelBinnedDataMap);
	    }
	    System.err.println(" included nuisance model");
	}

	// SIG : neutrino model to be tested
	if(!DataIsMap){
	    calSignal = new PoissonBinnedLikelihoodCalculator();
	    DataInputStream in = 
		//new DataInputStream(ClassLoader.getSystemResourceAsStream(sigEventRateFileName));
		new DataInputStream(new FileInputStream(sigEventRateFileName));
	    calSignal.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(sigEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    modelBinnedDataMap = null;
	    try{
		modelBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calSignal = 
		PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(modelBinnedDataMap);
	}

	System.err.format("expected sig rate (%f)\n",calSignal.getSumOfExpectedValues());

	if(!DataIsMap){
	    ModelULCalculatorByPoissonBinnedLikelihood.calculateUpperLimit();

	}else{
	    Iterator dataIterator = modelBinnedDataMap.entrySet().iterator();
	    while(dataIterator.hasNext()){
		Map.Entry entryData = (Map.Entry )(dataIterator.next());


		calSignal = (PoissonBinnedLikelihoodCalculator)(entryData.getKey());
		Map paraMap = (Map )(entryData.getValue());

		System.out.println("===========================");
		double mInThisModel = 0.0;
		if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterEvolution)){
		    Double mInThisModelObj =
			(Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterEvolution);
		    mInThisModel = mInThisModelObj.doubleValue();
		    System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterEvolution);
		    System.out.format(" = %f\n",mInThisModel);
		}
		double zmaxInThisModel = 0.0;
		if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterRedshift)){
		    Double zmaxInThisModelObj =
			(Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterRedshift);
		    zmaxInThisModel = zmaxInThisModelObj.doubleValue();
		    System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterRedshift);
		    System.out.format(" = %f\n",zmaxInThisModel);
		}
		double powerLawIndex = 0.0;
		if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterPowerLawIndex)){
		    Double powerLawIndexObj =
			(Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterPowerLawIndex);
		    powerLawIndex = powerLawIndexObj.doubleValue();
		    System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterPowerLawIndex);
		    System.out.format(" = %f\n",powerLawIndex);
		}
		double energyBase = 0.0;
		if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterEnergyBase)){
		    Double energyBaseObj =
			(Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterEnergyBase);
		    energyBase = energyBaseObj.doubleValue();
		    System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterEnergyBase);
		    System.out.format(" = %e\n",energyBase);
		}
		double eFlux = 0.0;
		if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterEnergyFluxAtBase)){
		    Double eFluxObj =
			(Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterEnergyFluxAtBase);
		    eFlux = eFluxObj.doubleValue();
		    System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterEnergyFluxAtBase);
		    System.out.format(" = %e\n",eFlux);
		}
		double cutoffEnergy = 0.0;
		if(paraMap.containsKey(PoissonBinnedLikelihoodMapBuilder.parameterCutoffEnergy)){
		    Double cutoffEnergyObj =
			(Double)paraMap.get(PoissonBinnedLikelihoodMapBuilder.parameterCutoffEnergy);
		    cutoffEnergy = cutoffEnergyObj.doubleValue();
		    System.out.print(PoissonBinnedLikelihoodMapBuilder.parameterCutoffEnergy);
		    System.out.format(" = %e\n",cutoffEnergy);
		}
		System.out.println("===========================");

		//ModelULCalculatorByPoissonBinnedLikelihood.confidenceLevel = 0.68;
		ModelULCalculatorByPoissonBinnedLikelihood.calculateUpperLimit();
	    }
	}

    }

   
}
