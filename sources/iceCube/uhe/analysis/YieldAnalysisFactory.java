package iceCube.uhe.analysis;

import iceCube.uhe.particles.*;
import iceCube.uhe.interactions.*;
import iceCube.uhe.analysis.*;
import numRecipes.*;

import java.io.*;
import java.util.*;

/**

   This class makes and handles histograms of
   the neutrino detection yield[cm^2 sec sr] generated by
   DumpQuickPropagationMatrixYield class 
   and neutrino cross section. The yield table
   is read out from the DataInputStream.

   Written by Shigeru Yoshida 2008/04/13

*/

public class YieldAnalysisFactory {

    static final double ln10 = Math.log(10.0);

    /** Maps to store the Yield Table */
    protected Map yieldMap = null;

    /** Neutrino InteractionMatrix object 
	to calculate the STANDARD cross section*/
    protected InteractionsMatrix nuCCMtx = null; 
    private String nuCCMtxObjectFile = "ENeutrinoChargeMtx";
    private String nuNCMtxObjectFile = "ENeutrinoNeutralMtx";

    /** Path to Intertaction Matrix file */
    protected static String[] intMtxPathname =
    {"iceCube/uhe/interactions/ice/","iceCube/uhe/interactions/rock/"};

    /** Range of the log(neutrino energy flux [GeV/cm^2 sec sr])
	in the histogram */
    protected double maxLogEFlux = -6.0; 
    protected double minLogEFlux = -12.0; 

    /** Range of the log(neutrino Charged Current cross section [cm^2])
	in the histogram */
    protected double maxLogSigmaCC = -31.0;
    protected double minLogSigmaCC = -34.0;

    /** Dimension of histogram */
    protected int dimensionHist = 100;

    // round-off error
    private double epsilon = 1.0e-5;

    /** Constructor. DataInputStream must be provided that lead to
     the yield table generated by DumpQuickPropagationMatrixYield class.*/
    public YieldAnalysisFactory(DataInputStream in, boolean chargedCurrent) throws IOException{
        yieldMap = new LinkedHashMap();
	// The Charged Current neutrino-nucleon
	String objectFile = null;
	if(chargedCurrent){
	    objectFile = 
		intMtxPathname[0].concat(nuCCMtxObjectFile); // ice CC
	}else{
	    objectFile = 
		intMtxPathname[0].concat(nuNCMtxObjectFile); // ice NC
	}
	InputStream inMtx = ClassLoader.getSystemResourceAsStream(objectFile);
	nuCCMtx = InteractionsMatrixInput.inputInteractionsMatrix(inMtx);
 
	readYieldTable(in);
    }

    /** Constructor. DataInputStream must be provided that lead to
     the yield table generated by DumpQuickPropagationMatrixYield class.*/
    public YieldAnalysisFactory(DataInputStream in) throws IOException{
	this(in,true);
    }

    /** Constructor. ObjectInputStream to get Map of (logE,map(sigma, yield)) 
	generated by MakeQuickPropagationYieldMap must be provided.*/
    public YieldAnalysisFactory(ObjectInputStream in) throws IOException{
	// The Charged Current neutrino-nucleon
	String objectFile = 
	    intMtxPathname[0].concat(nuCCMtxObjectFile); // ice
	InputStream inMtx = ClassLoader.getSystemResourceAsStream(objectFile);
	nuCCMtx = InteractionsMatrixInput.inputInteractionsMatrix(inMtx);
 
 	try{
	    yieldMap = (LinkedHashMap)in.readObject();
	}catch(ClassNotFoundException e){
	    System.err.println("Caught ClassNotFoundException: " + 
			       e.getMessage( ));
	    System.exit(0);
	}catch (EOFException e){
	    System.err.println("Caught EOFException: " + e.getMessage());
	    System.exit(0);
	}

    }

    /** Reads the yield table from the DataInoutStream
	and generate map(logE,map(sigmaCC,yield)) internally.*/
    protected void readYieldTable(DataInputStream in) throws IOException{

	// Reading data
	BufferedReader  d = new BufferedReader(new InputStreamReader(in));
	String buffer; int sep = 0; int sepstart = 0;
        char separator = ' ';
	while((buffer = d.readLine())!=null){
		// line -- nuEnhanceFactor, logE, yield
		sepstart = 0;
		//sep = buffer.indexOf(separator,sepstart+1);
		//sepstart = sep;

		sep = buffer.indexOf(separator,sepstart+1);
		double nuEnhanceFactor =
		    Double.valueOf(buffer.substring(sepstart+1,sep)).doubleValue( );
		sepstart = sep;

		sep = buffer.indexOf(separator,sepstart+1);
		double logE =
		    Double.valueOf(buffer.substring(sepstart+1,sep)).doubleValue( );
		sepstart = sep;

		sep = buffer.indexOf(separator,sepstart+1);
		double yield =
		    Double.valueOf(buffer.substring(sepstart+1,sep)).doubleValue( );
		sepstart = sep;

		// Calculate the relevant cross section
		int iLogE = (int )((logE+epsilon-Particle.getLogEnergyMinimum())/
                           Particle.getDeltaLogEnergy());
		double sigmaCC = nuCCMtx.getSigmaMatrix(iLogE)*nuEnhanceFactor;

		// Add the values to the map
		logE = Particle.getLogEnergyMinimum()+
		    Particle.getDeltaLogEnergy()*(double )iLogE;
		Double logEobject = new Double(logE);
		Double sigmaObject = new Double(sigmaCC);
		Double yieldObject = new Double(yield);
		LinkedHashMap sigmaYieldMap = null;
		if(yieldMap.containsKey(logEobject)){
		    sigmaYieldMap = (LinkedHashMap )yieldMap.get(logEobject);
		}else{
		    sigmaYieldMap = new LinkedHashMap();
		}
		sigmaYieldMap.put(sigmaObject,yieldObject);
		yieldMap.put(logEobject,sigmaYieldMap);

	}

    }

    /** Returns the map containing a pair of (cross section, yield)
	for a given log(Neutrino Energy [GeV])*/
    protected LinkedHashMap getSigmaYieldMap(double logNeutrinoEnergy){
	int iLogE = (int )((logNeutrinoEnergy+epsilon-
		    Particle.getLogEnergyMinimum())/Particle.getDeltaLogEnergy());
        double logE =  Particle.getLogEnergyMinimum()+
	    Particle.getDeltaLogEnergy()*(double )iLogE;
	Double logEobject = new Double(logE);
	if(yieldMap.containsKey(logEobject)){
	    return (LinkedHashMap )yieldMap.get(logEobject);
	}else{
	    return null;
	}
    }



    /** Print the yield table the method readYieldTable reads out
        in the constructor for a given log(Neutrino Energy [GeV]) 
	This method is mainly for debugging purposes.
    */
    public void printYield(double logNeutrinoEnergy){
	LinkedHashMap sigmaYieldMap = getSigmaYieldMap(logNeutrinoEnergy);
	if(sigmaYieldMap != null){
	    Iterator yieldIterator=sigmaYieldMap.entrySet().iterator();
	    while(yieldIterator.hasNext()){
		Map.Entry entry = (Map.Entry )(yieldIterator.next());
		double sigma = ((Double )(entry.getKey())).doubleValue();
		double yield = ((Double )(entry.getValue())).doubleValue();
		System.out.println(" yield = " + yield + 
				   " sigma (" + sigma + ")");
	    }
	}
    }

    /** getLogYield for a given log10(cross section [cm^2]) 
	using interplolation of the yield table read in the constructor.
	The map returned by getSigmaYieldMap(log10(neutrino energy[GeV])
	must be given.
    */
    protected double getLogYield(LinkedHashMap sigmaYieldMap,double logSigma){


	double rangeToInterpolate = 0.3; // range of values to be interpolated

	Iterator yieldIterator=sigmaYieldMap.entrySet().iterator();
	double[] yieldArray = new double[10];
	double[] sigmaArray = new double[10];
	int n = 0;
	while(yieldIterator.hasNext()){
	    Map.Entry entry = (Map.Entry )(yieldIterator.next());
	    double sigma = ((Double )(entry.getKey())).doubleValue();
	    double logSigmaInMap = Math.log(sigma)/ln10;
	    double yield = 
		((Double )(entry.getValue())).doubleValue();
	    if(Math.abs(logSigmaInMap-logSigma)<= rangeToInterpolate){
		if(n<yieldArray.length){
		    yieldArray[n]=Math.log(yield)/ln10;
		    sigmaArray[n++]=logSigmaInMap;
		}
	    }
	}
	//for(int i=0;i<n;i++)
	//    System.out.println(n + " yield = " + yieldArray[i] + 
	//		       " sigma (" + sigmaArray[i] + ")" +      
	//		       " " + logSigma);
	double[] xa = new double[n];
	double[] ya = new double[n];
	System.arraycopy(sigmaArray,0,xa,0,n);
	System.arraycopy(yieldArray,0,ya,0,n);

	double logYield = 
	    Interpolation.polynominalInterpolate(xa,ya,logSigma);
	return logYield;
    }


    /** Make a map of (neutrino crosssection [cm^2], 
	log10(neutrino energy flux [GeV/cm^2 sec sr])) for a given
	log10(neutrino energy [GeV]) and the number of events */
    public LinkedHashMap getSigmaFluxMap(double logNeutrinoEnergy,
					  double numEvents){

	int iLogE = 
	    (int )((logNeutrinoEnergy+epsilon-Particle.getLogEnergyMinimum())/
		   Particle.getDeltaLogEnergy());
	double sigmaCC = nuCCMtx.getSigmaMatrix(iLogE);
	minLogSigmaCC = Math.log(sigmaCC)/ln10;
	maxLogSigmaCC = Math.log(sigmaCC)/ln10 + 2.95; // 3 decade range


	LinkedHashMap sigmaYieldMap = getSigmaYieldMap(logNeutrinoEnergy);
	if(sigmaYieldMap != null){

	    LinkedHashMap sigmaFluxMap = new LinkedHashMap();

	    for(int iSigma=0;iSigma<dimensionHist;iSigma++){
		double logSigmaHist = minLogSigmaCC + 
		    ((maxLogSigmaCC-minLogSigmaCC)/(double )dimensionHist + epsilon)*
		    (double)iSigma;

		double logYield=getLogYield(sigmaYieldMap,logSigmaHist);

		double yield = Math.pow(10.0,logYield);
		double sigma =  Math.pow(10.0,logSigmaHist);
		//System.out.println(" yield = " + yield + 
		//		   " sigma (" + sigma + ")");

		double flux = numEvents/yield;
		double logFlux = Math.log(flux)/ln10;
		double logEFlux = logFlux +logNeutrinoEnergy - Math.log(ln10)/ln10;

		Double logSigmaObject = new Double(logSigmaHist);
		Double logEFluxObject = new Double(logEFlux);
		sigmaFluxMap.put(logSigmaObject,logEFluxObject);


	    }

	    return sigmaFluxMap;
	}

	return null;
    }

    /** Return the log(neutrino cross section [cm^2])
	for a given log10(neutrino energy [GeV]) that yields
	numEvents with log10(neutrino energy flux [GeV/cm^2 sec sr])
    */
    public double getLogSigma(double logNeutrinoEnergy,
			      double logEFlux, double numEvents){

	int iLogE = 
	    (int )((logNeutrinoEnergy+epsilon-Particle.getLogEnergyMinimum())/
		   Particle.getDeltaLogEnergy());
	double sigmaCC = nuCCMtx.getSigmaMatrix(iLogE);
	minLogSigmaCC = Math.log(sigmaCC)/ln10;
	maxLogSigmaCC = Math.log(sigmaCC)/ln10 + 2.95; // 3 decade range


	LinkedHashMap sigmaYieldMap = getSigmaYieldMap(logNeutrinoEnergy);
	double logSigmaSearch = maxLogSigmaCC;
	boolean gotBoundary = false;
	if(sigmaYieldMap != null){

	    for(int iSigma=0;iSigma<dimensionHist;iSigma++){
		logSigmaSearch = minLogSigmaCC + 
		    ((maxLogSigmaCC-minLogSigmaCC)/(double )dimensionHist + epsilon)*
		    (double)iSigma;

		double logYield=getLogYield(sigmaYieldMap,logSigmaSearch);

		double yield = Math.pow(10.0,logYield);

		double flux = numEvents/yield;
		double logFlux = Math.log(flux)/ln10;
		double logEFluxExpected = 
		    logFlux +logNeutrinoEnergy - Math.log(ln10)/ln10;

		if(logEFluxExpected<=logEFlux){
		    gotBoundary = true;
		    break;
		}

	    }

	}

	if(!gotBoundary) System.err.println("Warning:Cannot find the bound at "
					    + logNeutrinoEnergy);
	return logSigmaSearch;
    }

}
