package iceCube.uhe.analysis;

import numRecipes.*;
import iceCube.uhe.analysis.*;
import java.io.*;
import java.util.*;

/**

   Run the p-value distribution for p-value of the signal hypothesis
   against alternative signal hypothesis.
   The PoissonBinnedLikelihoodCalculator :
   <pre>
   PoissonBinnedLikelihoodCalculator  calBG     (for the atmospheric background)
   PoissonBinnedLikelihoodCalculator  calSinal   (for the neutrino model such as GZK to be tested)
   PoissonBinnedLikelihoodCalculator  calNuisanceSingal (for the nuisance signal - like E^-2 against the GZK test) 
   </pre>
   are generated by the correponding binned data from the files and then executes the methods
   provied by ModelTestByPoissonBinnedLikelihoodFactory.

   For each of a replica expetiment with the null hypothesis (calBG + calSignal), 
   the distribution of the likelihood ratio
   (bg + nuisance model signal with floated normalization)/(bg + model signal with floated normalization)
   is obtained by another replica experiment of (calBG + calSignal with floated normalization).

   For "hybrid" case,
   the distribution of the likelihood ratio
   (bg + nuisance + signal model signal with floated normalizations)/(bg + model signal with floated normalization)
   is calculated.
 </pre>

*/
public class RunSignalVsNuisanceSignal {

    public static void main(String[] args) throws IOException{

        PoissonBinnedLikelihoodCalculator calBG = null;
        PoissonBinnedLikelihoodCalculator calSignal = null;
        PoissonBinnedLikelihoodCalculator calNuisanceSignal = null;
	ModelTestByPoissonBinnedLikelihoodFactory testFactory = null;
	ModelTestByPoissonBinnedLikelihoodFactory testFactoryForMaximizedSignal = null;
	boolean runReplicaExperiment = true;
	boolean DataIsMap = false;
	boolean swapSig = false;
	int likelihoodRatioType = 4;
	int numberOfReplicaExpetimentUnderSignalhypothesis = 50;

	List pvalueList = null;

        String sigEventRateFileName = null;
        String nuisanceSigEventRateFileName = null;
        String bgEventRateFileName = null;
	String outputPvalueFileName = null;

        if(args.length<7){
            System.out.println("Usage: RunModelTestByPoissonBinnedLikelihood filename-to-read-BGdata filename-to-read-SIGdata filename-to-read-nusianceSigdata outputPvalueFileName dataIsMap(yes 1 no 0) runMultipleReplicaExperiment(yes 1 no-default 0) alternative-hybrid(yes 1 no-default 0) (swap sig<->nuisance?)");
            System.exit(0);
        }else {
            bgEventRateFileName = args[0];
            sigEventRateFileName = args[1];
	    nuisanceSigEventRateFileName = args[2];
	    outputPvalueFileName = args[3];
	    int index = Integer.valueOf(args[4]).intValue();
	    if(index == 1)  DataIsMap = true;
	    if(DataIsMap) System.err.println(" Binned Data in Map format is read out");
	    index = Integer.valueOf(args[5]).intValue();
	    if(index == 0){
		numberOfReplicaExpetimentUnderSignalhypothesis = 1;
		runReplicaExperiment = false;
	    }
	    index = Integer.valueOf(args[6]).intValue();
	    if(index == 1){
		likelihoodRatioType = 6;
		System.err.println("alternative hypotheis is hybrid");
	    }
	    if(args.length==8){
		swapSig = true;
		System.err.println("Swap signal and nuisance-sig hypothesis in pdf calculation");
	    }
	}

        // BG : background-only hypothesis
	if(!DataIsMap){
	    calBG = new PoissonBinnedLikelihoodCalculator();
	    DataInputStream in = 
		new DataInputStream(ClassLoader.getSystemResourceAsStream(bgEventRateFileName));
	    calBG.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(bgEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    Map bgBinnedDataMap = null;
	    try{
		bgBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calBG = PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(bgBinnedDataMap);
	}

	// SIG : neutrino model to be tested
	if(!DataIsMap){
	    calSignal = new PoissonBinnedLikelihoodCalculator();
	    DataInputStream in = 
		new DataInputStream(ClassLoader.getSystemResourceAsStream(sigEventRateFileName));
	    calSignal.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(sigEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    Map modelBinnedDataMap = null;
	    try{
		modelBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calSignal = 
		PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(modelBinnedDataMap);
	}

	// nuisance : alternative model to be tested
	if(!DataIsMap){
	    calNuisanceSignal = new PoissonBinnedLikelihoodCalculator();
	    DataInputStream in = new DataInputStream(ClassLoader.getSystemResourceAsStream(nuisanceSigEventRateFileName));
	    calNuisanceSignal.fillData(in);
	    in.close();
	}else{
	    FileInputStream in = new FileInputStream(nuisanceSigEventRateFileName);
	    ObjectInputStream objectIn = new ObjectInputStream(in);
	    Map nuisanceModelBinnedDataMap = null;
	    try{
		nuisanceModelBinnedDataMap = (Map )objectIn.readObject();
	    }catch(ClassNotFoundException e){
		System.err.println("Caught ClassNotFoundException: " + 
				   e.getMessage( ));
		System.exit(0);
	    }
	    in.close();
	    calNuisanceSignal = 
		PoissonBinnedLHExtracter.getPoisonBinnedLikelihoodCalculator(nuisanceModelBinnedDataMap);
	}


	// generate the ModelTestByPoissonBinnedLikelihoodFactory.
	testFactory = new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignal, calNuisanceSignal);
	testFactory.doNotIncludeNuisanceSignal();

	pvalueList = new LinkedList();
	// the lilelihood of null hypothesis (model + bg)
	for(int iRun = 0; iRun< numberOfReplicaExpetimentUnderSignalhypothesis; iRun++){
	    double llhNull = testFactory.buildLikelihoodForNullHypothesis(runReplicaExperiment);
	    double llhSignalFloated = testFactory.buildLikelihoodForAlternativeHypothesis(false,runReplicaExperiment);
	    double normFactorSignal = testFactory.getModelNormalizationToMaximizeLikelihood();
	    PoissonBinnedLikelihoodCalculator calSignalFloated = new PoissonBinnedLikelihoodCalculator();
	    calSignalFloated.useTheResultsByTheRealExperiment();
	    calSignal.useTheResultsByTheRealExperiment();
	    calSignalFloated.copyPoissonBinnedData(calSignal);
	    calSignalFloated.copyExpectedNumbers(normFactorSignal,calSignal);

	    double llhNuisanceSignalFloated = 
		testFactory.buildLikelihoodForAlternativeHypothesis(false,true,runReplicaExperiment);
	    double normFactorSignalNuisance = testFactory.getModelNormalizationToMaximizeLikelihood();
	    PoissonBinnedLikelihoodCalculator calNuisanceSignalFloated = new PoissonBinnedLikelihoodCalculator();
	    calNuisanceSignalFloated.useTheResultsByTheRealExperiment();
	    calNuisanceSignal.useTheResultsByTheRealExperiment();
	    calNuisanceSignalFloated.copyPoissonBinnedData(calNuisanceSignal);
	    calNuisanceSignalFloated.copyExpectedNumbers(normFactorSignalNuisance,calNuisanceSignal);

	    double llhRatioObserved = llhSignalFloated - llhNuisanceSignalFloated;
	    System.err.format("(%d) normFactorSig=%e normFactorSigNuisance=%e llhRatioOberved=%e\n",
			      iRun,normFactorSignal,normFactorSignalNuisance,llhRatioObserved);

	    if(!swapSig){
		testFactoryForMaximizedSignal = 
		    new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calSignalFloated, calNuisanceSignalFloated);
	    }else{
		testFactoryForMaximizedSignal = 
		    new ModelTestByPoissonBinnedLikelihoodFactory(calBG, calNuisanceSignalFloated,calSignalFloated);
		llhRatioObserved = -llhSignalFloated + llhNuisanceSignalFloated;
	    }
	    testFactoryForMaximizedSignal.doNotIncludeNuisanceSignal();

	    int runTimes = 10000;
	    testFactoryForMaximizedSignal.makeCollectionOfLogLikelihoodRatio(likelihoodRatioType,runTimes);
	    ListIterator llhRatioListIterator = testFactoryForMaximizedSignal.getllhRatioIterator();
	    double significance = 0.0;
	    int times = 0;
	    while(llhRatioListIterator.hasNext()){
		Double llhRatioObj = (Double )(llhRatioListIterator.next());
		double llhRatio = llhRatioObj.doubleValue();
		double pValue = 1.0-((double )times)/((double )runTimes);
		if(llhRatio< llhRatioObserved) significance = pValue;
		times++;
	    }
	    Double significanceObj =  new Double(significance);
	    pvalueList.add(significanceObj);
	    System.err.format("(%d) p-value=%e\n",iRun,significance);

	}
	Collections.sort(pvalueList);

	if(numberOfReplicaExpetimentUnderSignalhypothesis>1){
	    FileOutputStream out = new FileOutputStream(outputPvalueFileName); 
	    ObjectOutputStream objectOut = new ObjectOutputStream(out);
	    objectOut.writeObject(pvalueList);
	    objectOut.flush();
	    out.close();
	}

    }

   
}
