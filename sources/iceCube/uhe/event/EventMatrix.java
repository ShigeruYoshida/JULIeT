package  iceCube.uhe.event;

import iceCube.uhe.particles.*;
import iceCube.uhe.interactions.*;
import java.io.*;

/**
   This object handles a matrix table generated by 
   RunManager.runEventOnMatrix(DataOutputStream out, int numEvent).
   It gives a dN/dLogEcascade(mu or tau) where Ecascade is a total
   energy deposit in form of electrons or hadrons initiated by
   UHE muons or taus running in the detector voluce.
   Propagation of muons and tauons are treated by Event.java.

   The matrix table this object reads out is similar with 
   PropagationMatrix.getFtauToHadron(int iLogE,int jLogE) or
   PropagationMatrix.getFmuToHadron(int iLogE,int jLogE),
   for example, 
   in the propagation package. A main difference is 
   the PropagationMatrix is calculated by numerically
   solving the transport equation which is suitable
   for particle propagation in the Earth over long range
   while THIS matrix table is calculated by the Monte Carlo
   method by Event.java which works especially for particle
   propagation inside the detector volume where the fluctuation
   of the energy loss profile and total energy deposit from an event
   do matter.
  
*/

public class EventMatrix {

    static int dimension = Particle.getDimensionOfLogEnergyMatrix();
    static int expandedDim = dimension + 
                       (int )(( Particle.getLogEnergyMinimum()-InteractionsBase.getLogEnergyProducedMinimum())/
			      Particle.getDeltaLogEnergy());
    private double[][] emgCascadeMtx;
    private double[][] hadronCascadeMtx;
    private double[][] totalCascadeMtx;

    private int propFlavor = 0; //Flavor of the primary propagating particles.


    /** Constructor. Generate matrix array.*/
    public EventMatrix( ) {

        emgCascadeMtx    = new double[dimension][expandedDim];
        hadronCascadeMtx = new double[dimension][expandedDim];
        totalCascadeMtx = new double[dimension][expandedDim];

    }
    public EventMatrix(DataInputStream in ) throws IOException {

        emgCascadeMtx    = new double[dimension][expandedDim];
        hadronCascadeMtx = new double[dimension][expandedDim];
        totalCascadeMtx = new double[dimension][expandedDim];
	readMatrix(in);
    }


    /** Read the calculated event matrix by RunManager.runEventOnMatrix */
    public void readMatrix(DataInputStream in) throws IOException {
	propFlavor = in.readInt( );
        int iLogE;
        for(iLogE=0;iLogE<dimension;iLogE++){
            int jLogE;
            for(jLogE=0;jLogE<expandedDim;jLogE++){
                emgCascadeMtx[iLogE][jLogE]= in.readDouble( );
            }
        }

        for(iLogE=0;iLogE<dimension;iLogE++){
            int jLogE;
            for(jLogE=0;jLogE<expandedDim;jLogE++){
                hadronCascadeMtx[iLogE][jLogE]= in.readDouble( );
            }
        }

        for(iLogE=0;iLogE<dimension;iLogE++){
            int jLogE;
            for(jLogE=0;jLogE<expandedDim;jLogE++){
                totalCascadeMtx[iLogE][jLogE]= in.readDouble( );
            }
        }

        in.close( );

    }


    /** obtain primarily propagating particle flavor to initiate cascades.
	As defined in the Particle class, it should be either
	1 (muon) or 2 (tau). This value is read from the Matrix file
	by the method readMatrix( ) in this class.
    */

    public int getPropFlavor( ){
	return(propFlavor);
    }

    /** Obtain dN/dLogE  for electroMagnetic cascades */
    public double getEmgCascadeFlux(double logEprimary, double logEcascade){

	int iLogE = (int)((logEprimary - Particle.getLogEnergyMinimum())
			  /Particle.getDeltaLogEnergy());

	int jLogE = (int)((logEcascade - InteractionsBase.getLogEnergyProducedMinimum())
			  /Particle.getDeltaLogEnergy());

	double count = 0.0;
	if((0<=iLogE && iLogE<dimension) && (0<=jLogE && jLogE<expandedDim)){
	    count = emgCascadeMtx[iLogE][jLogE];
	}
	return(count);
   }

    /** Obtain dN/dLogE  for Hadron cascades */
    public double getHadronCascadeFlux(double logEprimary, double logEcascade){

	int iLogE = (int)((logEprimary - Particle.getLogEnergyMinimum())
			  /Particle.getDeltaLogEnergy());

	int jLogE = (int)((logEcascade - InteractionsBase.getLogEnergyProducedMinimum())
			  /Particle.getDeltaLogEnergy());

	double count = 0.0;
	if((0<=iLogE && iLogE<dimension) && (0<=jLogE && jLogE<expandedDim)){
	    count = hadronCascadeMtx[iLogE][jLogE];
	}
	return(count);
    }

    /** Obtain dN/dLogE  for Total cascades */
    public double getTotalCascadeFlux(double logEprimary, double logEcascade){

	int iLogE = (int)((logEprimary - Particle.getLogEnergyMinimum())
			  /Particle.getDeltaLogEnergy());

	int jLogE = (int)((logEcascade - InteractionsBase.getLogEnergyProducedMinimum())
			  /Particle.getDeltaLogEnergy());

	double count = 0.0;
	if((0<=iLogE && iLogE<dimension) && (0<=jLogE && jLogE<expandedDim)){
	    count = totalCascadeMtx[iLogE][jLogE];
	}
	return(count);
    }

}


