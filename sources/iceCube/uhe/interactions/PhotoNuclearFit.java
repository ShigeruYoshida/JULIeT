package iceCube.uhe.interactions;

import java.io.*;
import java.util.*;

import iceCube.uhe.particles.*;
import iceCube.uhe.points.*;
import numRecipes.*;

/** 
    <pre>
    The Photo Nuclear interactions
    taking place in undergound rock and ice are calculated in this subclass.

    The class variables  Particle, and Point are necessary for the methods
    described here because the cross section depends on the particle propaty
    and the medium like Z and A(atomic number).

    This class, different from PhotoNuclear.class, reads the numerical table
    generated by MakePhotoNuclearTable.java and calculate the relevant cross sections
    with numericaly interpolating the table.
    </pre>
*/

public class PhotoNuclearFit extends Interactions implements Function {

    private double[] para = new double[2];
    private double[ ] logEArray = new double[8];
    private double[ ] logDyArray = new double[14];
    private double[ ][ ] yDsigmaArray = new double[8][14];
    private static final double ln10 = Math.log(10.0);




    /** Constructor: Register the Particle and ParticlePoint classes.
	It also reads the pre-calculated y/E * dsigma/dy
        from the data file. */
    public PhotoNuclearFit(Particle p, ParticlePoint s) throws IOException {
	super(p, s, 3);

	String dataFile = null;
	String[] dataPath = {
	    "iceCube/uhe/interactions/ice/ALLM/","iceCube/uhe/interactions/rock/ALLM/"
	};
	String objectFile = null;

	if(p.getFlavor()==1) {
	    dataFile = "muPhotoNucl.dat";
	}else if(p.getFlavor()==2) {
	    dataFile = "tauPhotoNucl.dat";
	}

	objectFile = dataPath[s.getMaterialNumber()].concat(dataFile);
        DataInputStream in =  
            new DataInputStream(new FileInputStream(objectFile));


	int jLogY;
	for(jLogY=0;jLogY<14;jLogY++) logDyArray[jLogY] =in.readDouble();
	int iLogE;
	for(iLogE=0;iLogE<=7;iLogE++){
	    logEArray[iLogE] = in.readDouble( );
	    for(jLogY=0;jLogY<14;jLogY++){
		double ySigma = in.readDouble();
		if(ySigma != Double.NEGATIVE_INFINITY && ySigma != Double.NaN){
		    yDsigmaArray[iLogE][jLogY] = ySigma;
		}else{
		    yDsigmaArray[iLogE][jLogY] = yDsigmaArray[iLogE][jLogY-1];
		}
	    }
	}

        in.close( );
    }

    /** Differential cross section dsigma/dy [cm^2]
	y = 1 - Erecoiling/Eincoming -- inelasticity parameter    */
    public double getDSigmaDy(double y){
	if(!isValidInelasticity(y)) return 0.0;
	double logEnergy = Math.log(energy)/ln10;
	int index = Interpolation.searchIndex(logEArray,logEnergy,8);
	if(index>=6) index=6;
	double logELow = logEArray[index];
	double logEUp = logEArray[index+1];

	double logY = Math.log(y)/ln10;
	double dSigmaDyLow = 
	    Interpolation.mThPolynominalInterpolate(logDyArray,
	    yDsigmaArray[index],14,logY,4);
	double dSigmaDyUp = 
	    Interpolation.mThPolynominalInterpolate(logDyArray,
	    yDsigmaArray[index+1],14,logY,4);
	double yEdSigmaDy = dSigmaDyLow + (dSigmaDyUp-dSigmaDyLow)/(logEUp-logELow)*
	    (logEnergy-logELow);
	double dSigmaDy = Math.exp(yEdSigmaDy*ln10)*energy/y*1.0e-32;
	return dSigmaDy;
    }



    /** Checking the range of the given inelasticity y 
	that is determined in an individual interaction channel.
    */
    public boolean isValidInelasticity(double y){ 
        if((getYmin()+roundOffError)<= y && 
           y <= (getYmax()-roundOffError)) return true;
        else return false;
    }



    /** Getting the range of allowed y for a given interaction */
    public double getYmin( ){
	double yMin =  Math.pow(10.0,logDyArray[13]);
	return yMin;
    }
    public double getYmax( ){
	double yMax =  Math.pow(10.0,logDyArray[0]);
	return yMax;
    }


    /** Checking the particle kind involved with
	a given interaction. Only muons and taus
	are allowed to be involved with the photo-nuclear interaction
	in the medium.
    */
    public boolean isValidParticle(Particle p){
	if(p.getDoublet()==1 && p.getFlavor()>=1 && 3>p.getFlavor())
	return true;
	else return false;
    }



    /** Show Name of the Interaction */
    public String interactionName(){
        String channel = "Photo Nuclear Interaction ";
        String incidentParticle = 
            p.particleName(p.getFlavor(), p.getDoublet());
        String name = channel.concat("from ").concat(incidentParticle);
        return name;
    }

}



