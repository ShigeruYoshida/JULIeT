package iceCube.uhe.propagation;

import iceCube.uhe.particles.*;
import iceCube.uhe.interactions.*;
import iceCube.uhe.decay.*;
import iceCube.uhe.points.*;
import java.io.*;

/**
<pre>
  Propagation Matrix containing the neutrino interaction channel
  via the micro black hole creation-evaporation.
</pre>

*/

public class PropagationMatrixBHevaporation extends PropagationMatrix {

    // Week IntereactionMatrix generated by MakeNeutrinoBHevapMtx.java
    // The Interactions Object is
    // NeutrinoBHevaporation.java
    protected NeutrinoBHevaporationMatrix nuBHMtx = null; 
    protected String[] nuBHMtxObjectFile = {
	"ENeutrinoBHevapModel0Mtx", "ENeutrinoBHevapModel1Mtx",
    };


    /** Constructor. Reading all the InteractiosMatrix objects
	and generating the DecayMatrix objects. The infinitesimal propagation 
	distance dX [g/cm^2] is also determined here.*/
    public PropagationMatrixBHevaporation(Particle nuE, Particle nuMu, Particle nuTau,
			     Particle e,   Particle mu,   Particle tau,
			     Particle pi,  ParticlePoint s,
			     int interactionsSwitch, int decaySwitch,
   			     int modelNumber) throws IOException{

	super(nuE, nuMu, nuTau, e, mu, tau, pi, s,interactionsSwitch, decaySwitch, 1.0);

	// Reading the InteractionMatrix objects
	// the BH evaporation
	if((interactionsSwitch & CHARGED_FLAG) == CHARGED_FLAG){
	    String objectFile = null;
	    if(modelNumber <2){
		objectFile = pathName[s.getMaterialNumber()].concat(nuBHMtxObjectFile[modelNumber]);
	    }else{
		objectFile = pathName[s.getMaterialNumber()].concat(nuBHMtxObjectFile[0]);//default
	    }
	    System.err.println("Set object file name " + objectFile);
	    InputStream in = ClassLoader.getSystemResourceAsStream(objectFile);
	    System.err.println("Set input stream.");
	    nuBHMtx = (NeutrinoBHevaporationMatrix)InteractionsMatrixInput.inputInteractionsMatrix(in);
	    System.err.println("Set interaction Matrix.");
	    in.close( );
	    System.err.println("Closed input file.");
	}else{
	    System.err.println("BH creation interactions switched off.");
	}

	calculateTransferBHMatrix();
	System.err.println("Constructor PropagationMartixBHevaporation completed");

    }

    protected void calculateTransferBHMatrix() {
	int kLogE;
	for(kLogE=0;kLogE<dimension;kLogE++){

	    if((interactionsSwitch & CHARGED_FLAG) == CHARGED_FLAG){
		intProbNeutrino[kLogE] += dX*s.NA*nuBHMtx.getSigmaMatrix(kLogE);
	    }

	    int jLogE;
	    for(jLogE=0;jLogE<=kLogE;jLogE++){
		// to Mu and tau
		if((interactionsSwitch & CHARGED_FLAG) == CHARGED_FLAG){
		    nuEToMu[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getLeptonTransferMatrix(kLogE,jLogE);
		    nuMuToMu[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getLeptonTransferMatrix(kLogE,jLogE);
		    nuTauToMu[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getLeptonTransferMatrix(kLogE,jLogE);
		    nuEToTau[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getLeptonTransferMatrix(kLogE,jLogE);
		    nuMuToTau[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getLeptonTransferMatrix(kLogE,jLogE);
		    nuTauToTau[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getLeptonTransferMatrix(kLogE,jLogE);
		}

		// To Hadron (shower)
		if((interactionsSwitch & CHARGED_FLAG) == CHARGED_FLAG){
		    nuEToHadron[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getTransferMatrix(kLogE,jLogE);
		    nuMuToHadron[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getTransferMatrix(kLogE,jLogE);
		    nuTauToHadron[kLogE][jLogE] += 
			dX*s.NA*nuBHMtx.getTransferMatrix(kLogE,jLogE);
		}
	    }
	}
    }

}
